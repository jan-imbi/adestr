[{"path":"https://jan-imbi.github.io/adestr/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2021 Jan Meis Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://jan-imbi.github.io/adestr/articles/Introduction.html","id":"this-documentation-is-work-in-progress","dir":"Articles","previous_headings":"","what":"[This documentation is work in progress]","title":"Introduction to adestr","text":"package implements methods evaluate performance characteristics various point interval estimators adaptive two-stage designs prespecified sample-size recalculation rules. , allows evaluation estimators real datasets, implements methods calculate p-values. Currently, works designs objects produced R-package adoptr, calculates optimal design parameters adaptive two-stage designs. can learn adoptr : kkmann.github.io/adoptr/.","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/articles/Introduction.html","id":"evaluating-the-mean-squared-error-of-an-estimator","dir":"Articles","previous_headings":"[This documentation is work in progress] > Examples","what":"Evaluating the mean squared error of an estimator","title":"Introduction to adestr","text":"","code":"library(adestr) #> Loading required package: adoptr evaluate_estimator(  score = MSE(),  estimator = SampleMean(),  data_distribution = Normal(TRUE),  design = get_example_design(),  mu = c(0.3),  sigma = 1 ) #> Design:                              TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=10-39> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                                           Sample mean #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.3 #> Results: #>  Expectation:                                                          0.2816966 #>  Bias:                                                               -0.01830339 #>  Variance:                                                            0.07330464 #>  MSE:                                                                 0.07363966"},{"path":"https://jan-imbi.github.io/adestr/articles/Introduction.html","id":"analyzing-datasets","dir":"Articles","previous_headings":"[This documentation is work in progress] > Examples","what":"Analyzing datasets","title":"Introduction to adestr","text":"","code":"set.seed(321) dat <- data.frame(  endpoint = c(rnorm(28, .2, 1), rnorm(28, 0, 1),               rnorm(23, .2, 1), rnorm(23, 0, 1)),  group = factor(rep(c(\"ctl\", \"trt\", \"ctl\", \"trt\"),                     c(28,28,23,23))),  stage = rep(c(1L, 2L), c(56, 46)) ) analyze(  data = dat,  estimator = c(get_example_estimators()),  data_distribution = Normal(),  sigma = 1,  design = get_example_design() ) #> Design:                              TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=10-39> #> Data Distribution:                                             Normal<two-armed> #> Z1                                                                          1.75 #> Actual number of stages:                                                       2 #>  #> Stage 2 results: #>  Sample mean:                                                          0.5044685 #>  Pseudo Rao-Blackwellized:                                             0.3559511 #>  Median unbiased (LR test ordering):                                   0.4806717 #>  Bias reduced MLE (iterations=1):                                      0.4842482 #>  SWCF ordering CI:                                       [0.06262736, 0.7232758] #>  LR test ordering CI:                                     [0.2127897, 0.7949281] #>  SWCF ordering p-value:                                                 0.010977 #>  LR test ordering p-value:                                          0.0001877094"},{"path":"https://jan-imbi.github.io/adestr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jan Meis. Author, maintainer.","code":""},{"path":"https://jan-imbi.github.io/adestr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Meis J (2023). adestr: Adaptive Design Estimation R. R package version 0.0.1, https://jan-imbi.github.io/adestr/.","code":"@Manual{,   title = {adestr: Adaptive Design Estimation in R},   author = {Jan Meis},   year = {2023},   note = {R package version 0.0.1},   url = {https://jan-imbi.github.io/adestr/}, }"},{"path":"https://jan-imbi.github.io/adestr/index.html","id":"adestr-","dir":"","previous_headings":"","what":"Adaptive Design Estimation in R","title":"Adaptive Design Estimation in R","text":"package implements methods evaluate performance characteristics various point interval estimators adaptive two-stage designs prespecified sample-size recalculation rules. , allows evaluation estimators real datasets, implements methods calculate p-values. Currently, works designs objects produced R-package adoptr, calculates optimal design parameters adaptive two-stage designs.","code":""},{"path":"https://jan-imbi.github.io/adestr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Adaptive Design Estimation in R","text":"can install development version adestr typing R console.","code":"remotes::install_github(\"https://github.com/jan-imbi/adestr\")"},{"path":"https://jan-imbi.github.io/adestr/index.html","id":"information-for-reviewers","dir":"","previous_headings":"","what":"Information for reviewers","title":"Adaptive Design Estimation in R","text":"scripts reproduce results paper can found /data/code/ directory repository. results located /data/ directory. easiest way inspect results clone repository.","code":""},{"path":"https://jan-imbi.github.io/adestr/index.html","id":"general-example-for-usage-of-the-package","dir":"","previous_headings":"","what":"General example for usage of the package","title":"Adaptive Design Estimation in R","text":"quick example showing capabilities adestr. First, load adestr: , can evaluate performance estimator like : can analyze dataset like :","code":"library(adestr) #> Loading required package: adoptr evaluate_estimator(  score = MSE(),  estimator = SampleMean(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(),  mu = c(0, 0.3, 0.6),  sigma = 1 ) #> Design:                              TwoStageDesign<n1=28;0.8<=x1<=2.3;n2=10-40> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                                           Sample mean #> Assumed sigma:                                                                 1 #> Assumed mu:                                                          0.0 0.3 0.6 #> Results: #>  Expectation:                                -0.03523827  0.28169661  0.63556747 #>  Bias:                                       -0.03523827 -0.01830339  0.03556747 #>  Variance:                                      0.05558910 0.07330464 0.06591361 #>  MSE:                                           0.05683084 0.07363966 0.06717865 set.seed(321) dat <- data.frame(  endpoint = c(rnorm(28, .2, 1), rnorm(28, 0, 1),               rnorm(23, .2, 1), rnorm(23, 0, 1)),  group = factor(rep(c(\"ctl\", \"trt\", \"ctl\", \"trt\"),                     c(28,28,23,23))),  stage = rep(c(1L, 2L), c(56, 46)) ) analyze(  data = dat,  estimator = get_example_estimators(),  data_distribution = Normal(),  sigma = 1,  design = get_example_design() ) #> Design:                              TwoStageDesign<n1=28;0.8<=x1<=2.3;n2=10-40> #> Data Distribution:                                             Normal<two-armed> #> Z1                                                                          1.75 #> Actual number of stages:                                                       2 #>  #> Stage 2 results: #>  Sample mean:                                                          0.5044685 #>  Pseudo Rao-Blackwellized:                                             0.3559511 #>  Median unbiased (LR test ordering):                                   0.4806717 #>  Bias reduced MLE (iterations=1):                                      0.4994132 #>  SWCF ordering CI:                                       [0.06262736, 0.7232758] #>  LR test ordering CI:                                     [0.2127897, 0.7949281] #>  SWCF ordering p-value:                                                 0.010977 #>  LR test ordering p-value:                                          0.0001877094"},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Performance scores for point and interval estimators — EstimatorScore-class","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"functions encode various metrics can used evaluate performance characteristics point interval estimators.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"","code":"Expectation()  Bias()  Variance()  MSE()  OverestimationProbability()  Coverage()  SoftCoverage(shrinkage = 1)  Width()  TestAgreement()"},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"shrinkage shrinkage factor bump function.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"EstimatorScore object.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"label name performance score. Used printing methods.","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"","code":"evaluate_estimator(   score = MSE(),   estimator = SampleMean(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu = c(0.3),   sigma = 1,   exact = FALSE ) #> Design:                              TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=10-39> #> Data Distribution:                                          Normal<single-armed> #> Estimator:                                                           Sample mean #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.3 #> Results: #>  Expectation:                                                          0.3056919 #>  Bias:                                                                0.00569194 #>  Variance:                                                            0.03778007 #>  MSE:                                                                 0.03781247 #>"},{"path":"https://jan-imbi.github.io/adestr/reference/IntervalEstimator-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Interval estimators — IntervalEstimator-class","title":"Interval estimators — IntervalEstimator-class","text":"Interval estimators","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/IntervalEstimator-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interval estimators — IntervalEstimator-class","text":"","code":"IntervalEstimator(two_sided, l1, u1, l2, u2, label)  VirtualIntervalEstimator()  RepeatedCI(two_sided = TRUE)  StagewiseCombinationFunctionOrderingCI(two_sided = TRUE)  MLEOrderingCI(two_sided = TRUE)  LikelihoodRatioOrderingCI(two_sided = TRUE)  ScoreTestOrderingCI(two_sided = TRUE)  NaiveCI(two_sided = TRUE)  NeymanPearsonOrderingCI(two_sided = TRUE, mu0 = 0, mu1 = 0.4)"},{"path":"https://jan-imbi.github.io/adestr/reference/IntervalEstimator-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interval estimators — IntervalEstimator-class","text":"two_sided logical indicating whether confidence interval two-sided. l1 functional representation lower boundary interval early futility efficacy regions. u1 functional representation upper boundary interval early futility efficacy regions. l2 functional representation lower boundary interval continuation region. u2 functional representation upper boundary interval continuation region. label name estimator. Used printing methods. mu0 expected value normal distribution null hypothesis. mu1 expected value normal distribution null hypothesis.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/IntervalEstimator-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interval estimators — IntervalEstimator-class","text":"object class IntervalEstimator.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/IntervalEstimator-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interval estimators — IntervalEstimator-class","text":"","code":"IntervalEstimator(   two_sided = FALSE,   l1 = \\(smean1, ...) smean1 - 1,   u1 = \\(smean1, ...) smean1 + 1,   l2 = \\(smean2, ...) smean2 - 1,   u2 = \\(smean2, ...) smean2 + 1,   label=\"My custom p-value\") #> My custom p-value"},{"path":"https://jan-imbi.github.io/adestr/reference/PValue-class.html","id":null,"dir":"Reference","previous_headings":"","what":"P-values — PValue-class","title":"P-values — PValue-class","text":"P-values","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PValue-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"P-values — PValue-class","text":"","code":"PValue(g1, g2, label)  VirtualPValue()  LinearShiftRepeatedPValue(wc1f = 0, wc1e = 1/2, wc2 = 1/2)  MLEOrderingPValue()  LikelihoodRatioOrderingPValue()  ScoreTestOrderingPValue()  StagewiseCombinationFunctionOrderingPValue()  NeymanPearsonOrderingPValue(mu0 = 0, mu1 = 0.4)"},{"path":"https://jan-imbi.github.io/adestr/reference/PValue-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"P-values — PValue-class","text":"g1 functional representation p-value early futility efficacy regions. g2 functional representation p-value continuation region. label name p-value. Used printing methods. wc1f slope futility boundary change. wc1e slope efficacy boundary change. wc2 slope c2 boundary change. mu0 expected value normal distribution null hypothesis. mu1 expected value normal distribution null hypothesis.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PValue-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"P-values — PValue-class","text":"object class PValue.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PValue-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"P-values — PValue-class","text":"","code":"PValue(   g1 = \\(smean1, ...) runif(length(smean1)),   g2 = \\(smean2, ...) runif(length(smean2)),   label=\"My custom p-value\") #> My custom p-value"},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Point estimators — PointEstimator-class","title":"Point estimators — PointEstimator-class","text":"Point estimators","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Point estimators — PointEstimator-class","text":"","code":"PointEstimator(g1, g2, label)  VirtualPointEstimator()  SampleMean()  FirstStageSampleMean()  WeightedSampleMean(w1 = 0.5)  AdaptivelyWeightedSampleMean(w1 = 1/sqrt(2))  MinimizePeakVariance()  BiasReduced(iterations = 1L)  RaoBlackwell()  PseudoRaoBlackwell()  MidpointStagewiseCombinationFunctionOrderingCI()  MidpointMLEOrderingCI()  MidpointLikelihoodRatioOrderingCI()  MidpointScoreTestOrderingCI()  MedianUnbiasedStagewiseCombinationFunctionOrdering()  MedianUnbiasedMLEOrdering()  MedianUnbiasedLikelihoodRatioOrdering()  MedianUnbiasedScoreTestOrdering()  MedianUnbiasedNeymanPearsonOrdering(mu0 = 0, mu1 = 0.4)  MidpointNeymanPearsonOrderingCI()"},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Point estimators — PointEstimator-class","text":"g1 functional representation estimator early futility efficacy regions. g2 functional representation estimator continuation region. label name estimator. Used printing methods. w1 weight first-stage sample mean. iterations number bias reduction iterations. Defaults 1. mu0 expected value normal distribution null hypothesis. mu1 expected value normal distribution null hypothesis.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Point estimators — PointEstimator-class","text":"object class PointEstimator.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Point estimators — PointEstimator-class","text":"","code":"PointEstimator(g1 = \\(smean1, ...) smean1,g2 = \\(smean2, ...) smean2, label=\"My custom estimator\") #> My custom estimator"},{"path":"https://jan-imbi.github.io/adestr/reference/adestr.html","id":null,"dir":"Reference","previous_headings":"","what":"adestr — adestr","title":"adestr — adestr","text":"Adaptive Design Estimation R","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/adestr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"adestr — adestr","text":"flexibility adaptive clinical trial designs can offer significant advantages fixed designs. design parameters chosen appropriately, adaptive designs can decrease expected sample size save resources cases early evidence continuation trial may futile. known issue adaptive designs estimators appropriate single-stage fixed design, maximum likelihood estimator, can biased due dependence structure data introduced adaptivity. problem affects point estimators well confidence intervals p-values. Regulatory agencies EMA FDA recognize problem urge researchers \"extent bias evaluated, estimates presented appropriate cautions regarding interpretation\". years, various methods proposed mitigate bias introduced adaptive designs. However, estimators often need fulfill requirements useful practice, acceptable variance. work, provide results operating characteristics different estimators optimal adaptive two-stage design normally distributed outcome. optimal designs, design parameters sample sizes, decision boundaries, adaptation rules chosen result optimization process. goal optimization process maximize metric design quality, typical example expected sample size required fulfill certain power requirements specified hypothesis. Although optimal adaptive designs topic recent research, guidance estimation novel kind designs still scarce. compare classical recently developed point estimators well estimation methods confidence intervals p-values regarding various performance criteria bias, variance, mean squared error, coverage, consistency test decisions.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/analyze.html","id":null,"dir":"Reference","previous_headings":"","what":"Analyze a dataset — analyze","title":"Analyze a dataset — analyze","text":"Analyze dataset","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/analyze.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analyze a dataset — analyze","text":"","code":"analyze(   data,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for data.frame analyze(   data,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )"},{"path":"https://jan-imbi.github.io/adestr/reference/analyze.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Analyze a dataset — analyze","text":"data data.frame containing data analyzed estimator object class PointEstimator, IntervalEstimator PValue. data_distribution object class Normal Student. use_full_twoarm_sampling_distribution logical indicating whether estimator intended used full sampling distribution two-armed trial design object class TwoStageDesign. sigma assumed standard deviation. exact logical indicating usage exact n2 function.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/analyze.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Analyze a dataset — analyze","text":"Results object containing values estimators applied data.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/analyze.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Analyze a dataset — analyze","text":"","code":"set.seed(321) dat <- data.frame(   endpoint = c(rnorm(28, .2, 1), rnorm(28, 0, 1),                rnorm(23, .2, 1), rnorm(23, 0, 1)),   group = factor(rep(c(\"ctl\", \"trt\", \"ctl\", \"trt\"),                      c(28,28,23,23))),   stage = rep(c(1L, 2L), c(56, 46)) ) analyze(   data = dat,   estimator = c(get_example_estimators()),   data_distribution = Normal(),   sigma = 1,   design = get_example_design() ) #> Design:                              TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=10-39> #> Data Distribution:                                             Normal<two-armed> #> Z1                                                                          1.75 #> Actual number of stages:                                                       2 #>  #> Stage 2 results: #>  Sample mean:                                                          0.5044685 #>  Pseudo Rao-Blackwellized:                                             0.3559511 #>  Median unbiased (LR test ordering):                                   0.4806717 #>  Bias reduced MLE (iterations=1):                                      0.4842482 #>  SWCF ordering CI:                                       [0.06262736, 0.7232758] #>  LR test ordering CI:                                     [0.2127897, 0.7949281] #>  SWCF ordering p-value:                                                 0.010977 #>  LR test ordering p-value:                                          0.0001877094 #>"},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate performance characteristics of an estimator — evaluate_estimator","title":"Evaluate performance characteristics of an estimator — evaluate_estimator","text":"Evaluate performance characteristics estimator","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate performance characteristics of an estimator — evaluate_estimator","text":"","code":"evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for PointEstimatorScore,IntervalEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for IntervalEstimatorScore,PointEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for list,Estimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for Expectation,PointEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for Bias,PointEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for Variance,PointEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for MSE,PointEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for OverestimationProbability,PointEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for Coverage,IntervalEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for SoftCoverage,IntervalEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for Width,IntervalEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for TestAgreement,IntervalEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )"},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate performance characteristics of an estimator — evaluate_estimator","text":"score performance measure evaluate. estimator object class PointEstimator, IntervalEstimator PValue. data_distribution object class Normal Student. use_full_twoarm_sampling_distribution logical indicating whether estimator intended used full sampling distribution two-armed trial design object class TwoStageDesign. true_parameter true value parameter (used e.g. evaluating bias) mu expected value underlying normal distribution sigma assumed standard deviation. tol relative tolerance maxEval maximum number iterations absError absolute tolerance exact logical indicating usage exact n2 function. early_futility_part include early futility part integral continuation_part include continuation part integral early_efficacy_part include early efficacy part integral conditional_integral treat integral conditional integral.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate performance characteristics of an estimator — evaluate_estimator","text":"EstimatorScoreResult object containing performance characteristics estimator.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate performance characteristics of an estimator — evaluate_estimator","text":"","code":"evaluate_estimator(   score = MSE(),   estimator = SampleMean(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu = c(0.3),   sigma = 1,   exact = FALSE ) #> Design:                              TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=10-39> #> Data Distribution:                                          Normal<single-armed> #> Estimator:                                                           Sample mean #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.3 #> Results: #>  Expectation:                                                          0.3056919 #>  Bias:                                                                0.00569194 #>  Variance:                                                            0.03778007 #>  MSE:                                                                 0.03781247 #>"},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_scenarios_parallel.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate different scenarios in parallel — evaluate_scenarios_parallel","title":"Evaluate different scenarios in parallel — evaluate_scenarios_parallel","text":"function takes list lists scores, list lists estimators, lists lists various design parameters. possible combination elements respective sublists used create separate scenario. scenarios evaluated independelty , allowing parallelization via future framework.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_scenarios_parallel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate different scenarios in parallel — evaluate_scenarios_parallel","text":"","code":"evaluate_scenarios_parallel(   score_lists,   estimator_lists,   data_distribution_lists,   use_full_twoarm_sampling_distribution_lists,   design_lists,   true_parameter_lists,   mu_lists,   sigma_lists,   tol_lists,   maxEval_lists,   absError_lists,   exact_lists,   early_futility_part_lists,   continuation_part_lists,   early_efficacy_part_lists,   conditional_integral_lists )"},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_scenarios_parallel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate different scenarios in parallel — evaluate_scenarios_parallel","text":"score_lists list lists estimator scores. estimator_lists list lists estimators. data_distribution_lists list lists data distributions. use_full_twoarm_sampling_distribution_lists list lists use_full_twoarm_sampling_distribution_lists parameters. design_lists list lists designs. true_parameter_lists list lists true parameters. mu_lists list lists mu vectors. sigma_lists list lists sigma values. tol_lists list lists relative tolerances. maxEval_lists list lists maxEval boundaries. absError_lists list lists absError boundaries. exact_lists list lists `exact` parameters. early_futility_part_lists list lists `early_futility_part_lists` parameters. continuation_part_lists list lists `continuation_part_lists` parameters. early_efficacy_part_lists list lists `early_efficacy_part_lists` parameters. conditional_integral_lists list lists `conditional_integral_lists` parameters.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_scenarios_parallel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate different scenarios in parallel — evaluate_scenarios_parallel","text":"list data.frames containing results respective scenarios.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_scenarios_parallel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate different scenarios in parallel — evaluate_scenarios_parallel","text":"","code":"res <-evaluate_scenarios_parallel(  score_lists = list(c(MSE(), OverestimationProbability())),  estimator_lists =  list(c(SampleMean(), FirstStageSampleMean())),  data_distribution_lists = list(c(Normal(FALSE), Normal(TRUE))),  design_lists =  list(c(get_example_design())),  mu_lists = list(c(-1, 0, 1)),  sigma_lists = list(1) )"},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_design.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate an exemplary adaptive design — get_example_design","title":"Generate an exemplary adaptive design — get_example_design","text":"design optimized minimize expected sample size alternative hypothesis one-armed trial. boundaries chosen control type error 0.025 normally distributed test statistic (.e. known variance). alternative hypothesis mu=0.4, overall power 80%.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate an exemplary adaptive design — get_example_design","text":"","code":"get_example_design()"},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_design.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate an exemplary adaptive design — get_example_design","text":"exmplary design class TwoStageDesign.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_design.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate an exemplary adaptive design — get_example_design","text":"","code":"design <- get_example_design() # Type I error evaluate(Power(Normal(FALSE), PointMassPrior(0, 1)), design) #> [1] 0.02500571 # Power evaluate(Power(Normal(FALSE), PointMassPrior(.4, 1)), design) #> [1] 0.7985303 # Expected sample size under the alternative evaluate(ExpectedSampleSize(Normal(FALSE), PointMassPrior(.4, 1)), design) #> [1] 39.85593 # Expected sample size under the null evaluate(ExpectedSampleSize(Normal(FALSE), PointMassPrior(0, 1)), design) #> [1] 34.45135"},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_estimators.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a list of estimators and p-values to use in examples — get_example_estimators","title":"Generate a list of estimators and p-values to use in examples — get_example_estimators","text":"Generate list estimators p-values use examples","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_estimators.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a list of estimators and p-values to use in examples — get_example_estimators","text":"","code":"get_example_estimators(   point_estimators = TRUE,   interval_estimators = TRUE,   p_values = TRUE )"},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_estimators.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a list of estimators and p-values to use in examples — get_example_estimators","text":"point_estimators logical indicating whether point estimators included output list interval_estimators logical indicating whether interval estimators included output list p_values logical indicating whether p-values included output list","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_estimators.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a list of estimators and p-values to use in examples — get_example_estimators","text":"list estimators pvalues.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_estimators.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a list of estimators and p-values to use in examples — get_example_estimators","text":"","code":"set.seed(321) dat <- data.frame(   endpoint = c(rnorm(28, .2, 1), rnorm(28, 0, 1),                rnorm(23, .2, 1), rnorm(23, 0, 1)),   group = factor(rep(c(\"ctl\", \"trt\", \"ctl\", \"trt\"),                      c(28,28,23,23))),   stage = rep(c(1L, 2L), c(56, 46)) ) analyze(   data = dat,   estimator = c(get_example_estimators()),   data_distribution = Normal(),   sigma = 1,   design = get_example_design() ) #> Design:                              TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=10-39> #> Data Distribution:                                             Normal<two-armed> #> Z1                                                                          1.75 #> Actual number of stages:                                                       2 #>  #> Stage 2 results: #>  Sample mean:                                                          0.5044685 #>  Pseudo Rao-Blackwellized:                                             0.3559511 #>  Median unbiased (LR test ordering):                                   0.4806717 #>  Bias reduced MLE (iterations=1):                                      0.4842482 #>  SWCF ordering CI:                                       [0.06262736, 0.7232758] #>  LR test ordering CI:                                     [0.2127897, 0.7949281] #>  SWCF ordering p-value:                                                 0.010977 #>  LR test ordering p-value:                                          0.0001877094 #>"},{"path":"https://jan-imbi.github.io/adestr/reference/get_stagewise_estimators.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional representations of an estimator or p-value — get_stagewise_estimators","title":"Conditional representations of an estimator or p-value — get_stagewise_estimators","text":"generic determines functional representations point interval estimators p-values. functions returned two parts, one part calculate values conditional early futility efficacy stops (.e. second stage mean sample size available), one conditional continuation second stage.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_stagewise_estimators.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditional representations of an estimator or p-value — get_stagewise_estimators","text":"","code":"get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for VirtualPointEstimator,ANY get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for VirtualPValue,ANY get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for VirtualIntervalEstimator,ANY get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for PointEstimator,Student get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for PValue,Student get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for IntervalEstimator,Student get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for VirtualPointEstimator,Student get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for VirtualIntervalEstimator,Student get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for VirtualPValue,Student get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for PointEstimator,DataDistribution get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for PValue,DataDistribution get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for IntervalEstimator,DataDistribution get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for AdaptivelyWeightedSampleMean,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MinimizePeakVariance,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for BiasReduced,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for RaoBlackwell,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for PseudoRaoBlackwell,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for RepeatedCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for LinearShiftRepeatedPValue,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MLEOrderingPValue,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for LikelihoodRatioOrderingPValue,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for ScoreTestOrderingPValue,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for StagewiseCombinationFunctionOrderingPValue,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for StagewiseCombinationFunctionOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MLEOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for LikelihoodRatioOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for ScoreTestOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for NaiveCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MidpointStagewiseCombinationFunctionOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MidpointMLEOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MidpointLikelihoodRatioOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MidpointScoreTestOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MedianUnbiasedStagewiseCombinationFunctionOrdering,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MedianUnbiasedMLEOrdering,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MedianUnbiasedLikelihoodRatioOrdering,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MedianUnbiasedScoreTestOrdering,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for NeymanPearsonOrderingPValue,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for NeymanPearsonOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MedianUnbiasedNeymanPearsonOrdering,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MidpointNeymanPearsonOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )"},{"path":"https://jan-imbi.github.io/adestr/reference/get_stagewise_estimators.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conditional representations of an estimator or p-value — get_stagewise_estimators","text":"estimator object class PointEstimator, IntervalEstimator PValue. data_distribution object class Normal Student. use_full_twoarm_sampling_distribution logical indicating whether estimator intended used full sampling distribution two-armed trial design object class TwoStageDesign. sigma assumed standard deviation. exact logical indicating usage exact n2 function.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_stagewise_estimators.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conditional representations of an estimator or p-value — get_stagewise_estimators","text":"list conditional functional representations (one stage trial might end) estimator p-value.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_stagewise_estimators.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditional representations of an estimator or p-value — get_stagewise_estimators","text":"","code":"get_stagewise_estimators(   estimator = SampleMean(),   data_distribution = Normal(FALSE),   use_full_twoarm_sampling_distribution = FALSE,   design = get_example_design(),   sigma = 1,   exact = FALSE ) #> $g1 #> function (smean1, ...)  #> smean1 #> <bytecode: 0x557eb2120208> #> <environment: 0x557eb4963f48> #>  #> $g2 #> function (smean1, smean2, n1, n2, ...)  #> (n1 * smean1 + n2 * smean2)/(n1 + n2) #> <bytecode: 0x557eb211fec0> #> <environment: 0x557eb4963f48> #>"},{"path":"https://jan-imbi.github.io/adestr/news/index.html","id":"adestr-001","dir":"Changelog","previous_headings":"","what":"adestr 0.0.1","title":"adestr 0.0.1","text":"Added NEWS.md file track changes package.","code":""}]
