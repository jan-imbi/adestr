[{"path":"https://jan-imbi.github.io/adestr/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 2, June 1991Copyright © 1989, 1991 Free Software Foundation, Inc.,51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://jan-imbi.github.io/adestr/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"licenses software designed take away freedom share change . contrast, GNU General Public License intended guarantee freedom share change free software–make sure software free users. General Public License applies Free Software Foundation’s software program whose authors commit using . (Free Software Foundation software covered GNU Lesser General Public License instead.) can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge service wish), receive source code can get want , can change software use pieces new free programs; know can things. protect rights, need make restrictions forbid anyone deny rights ask surrender rights. restrictions translate certain responsibilities distribute copies software, modify . example, distribute copies program, whether gratis fee, must give recipients rights . must make sure , , receive can get source code. must show terms know rights. protect rights two steps: (1) copyright software, (2) offer license gives legal permission copy, distribute /modify software. Also, author’s protection , want make certain everyone understands warranty free software. software modified someone else passed , want recipients know original, problems introduced others reflect original authors’ reputations. Finally, free program threatened constantly software patents. wish avoid danger redistributors free program individually obtain patent licenses, effect making program proprietary. prevent , made clear patent must licensed everyone’s free use licensed . precise terms conditions copying, distribution modification follow.","code":""},{"path":"https://jan-imbi.github.io/adestr/LICENSE.html","id":"terms-and-conditions-for-copying-distribution-and-modification","dir":"","previous_headings":"","what":"TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION","title":"GNU General Public License","text":"0. License applies program work contains notice placed copyright holder saying may distributed terms General Public License. “Program”, , refers program work, “work based Program” means either Program derivative work copyright law: say, work containing Program portion , either verbatim modifications /translated another language. (Hereinafter, translation included without limitation term “modification”.) licensee addressed “”. Activities copying, distribution modification covered License; outside scope. act running Program restricted, output Program covered contents constitute work based Program (independent made running Program). Whether true depends Program . 1. may copy distribute verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice disclaimer warranty; keep intact notices refer License absence warranty; give recipients Program copy License along Program. may charge fee physical act transferring copy, may option offer warranty protection exchange fee. 2. may modify copy copies Program portion , thus forming work based Program, copy distribute modifications work terms Section 1 , provided also meet conditions: ) must cause modified files carry prominent notices stating changed files date change. b) must cause work distribute publish, whole part contains derived Program part thereof, licensed whole charge third parties terms License. c) modified program normally reads commands interactively run, must cause , started running interactive use ordinary way, print display announcement including appropriate copyright notice notice warranty (else, saying provide warranty) users may redistribute program conditions, telling user view copy License. (Exception: Program interactive normally print announcement, work based Program required print announcement.) requirements apply modified work whole. identifiable sections work derived Program, can reasonably considered independent separate works , License, terms, apply sections distribute separate works. distribute sections part whole work based Program, distribution whole must terms License, whose permissions licensees extend entire whole, thus every part regardless wrote . Thus, intent section claim rights contest rights work written entirely ; rather, intent exercise right control distribution derivative collective works based Program. addition, mere aggregation another work based Program Program (work based Program) volume storage distribution medium bring work scope License. 3. may copy distribute Program (work based , Section 2) object code executable form terms Sections 1 2 provided also one following: ) Accompany complete corresponding machine-readable source code, must distributed terms Sections 1 2 medium customarily used software interchange; , b) Accompany written offer, valid least three years, give third party, charge cost physically performing source distribution, complete machine-readable copy corresponding source code, distributed terms Sections 1 2 medium customarily used software interchange; , c) Accompany information received offer distribute corresponding source code. (alternative allowed noncommercial distribution received program object code executable form offer, accord Subsection b .) source code work means preferred form work making modifications . executable work, complete source code means source code modules contains, plus associated interface definition files, plus scripts used control compilation installation executable. However, special exception, source code distributed need include anything normally distributed (either source binary form) major components (compiler, kernel, ) operating system executable runs, unless component accompanies executable. distribution executable object code made offering access copy designated place, offering equivalent access copy source code place counts distribution source code, even though third parties compelled copy source along object code. 4. may copy, modify, sublicense, distribute Program except expressly provided License. attempt otherwise copy, modify, sublicense distribute Program void, automatically terminate rights License. However, parties received copies, rights, License licenses terminated long parties remain full compliance. 5. required accept License, since signed . However, nothing else grants permission modify distribute Program derivative works. actions prohibited law accept License. Therefore, modifying distributing Program (work based Program), indicate acceptance License , terms conditions copying, distributing modifying Program works based . 6. time redistribute Program (work based Program), recipient automatically receives license original licensor copy, distribute modify Program subject terms conditions. may impose restrictions recipients’ exercise rights granted herein. responsible enforcing compliance third parties License. 7. , consequence court judgment allegation patent infringement reason (limited patent issues), conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. distribute satisfy simultaneously obligations License pertinent obligations, consequence may distribute Program . example, patent license permit royalty-free redistribution Program receive copies directly indirectly , way satisfy License refrain entirely distribution Program. portion section held invalid unenforceable particular circumstance, balance section intended apply section whole intended apply circumstances. purpose section induce infringe patents property right claims contest validity claims; section sole purpose protecting integrity free software distribution system, implemented public license practices. Many people made generous contributions wide range software distributed system reliance consistent application system; author/donor decide willing distribute software system licensee impose choice. section intended make thoroughly clear believed consequence rest License. 8. distribution /use Program restricted certain countries either patents copyrighted interfaces, original copyright holder places Program License may add explicit geographical distribution limitation excluding countries, distribution permitted among countries thus excluded. case, License incorporates limitation written body License. 9. Free Software Foundation may publish revised /new versions General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies version number License applies “later version”, option following terms conditions either version later version published Free Software Foundation. Program specify version number License, may choose version ever published Free Software Foundation. 10. wish incorporate parts Program free programs whose distribution conditions different, write author ask permission. software copyrighted Free Software Foundation, write Free Software Foundation; sometimes make exceptions . decision guided two goals preserving free status derivatives free software promoting sharing reuse software generally.","code":""},{"path":"https://jan-imbi.github.io/adestr/LICENSE.html","id":"no-warranty","dir":"","previous_headings":"","what":"NO WARRANTY","title":"GNU General Public License","text":"11. PROGRAM LICENSED FREE CHARGE, WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION. 12. EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MAY MODIFY /REDISTRIBUTE PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES. END TERMS CONDITIONS","code":""},{"path":"https://jan-imbi.github.io/adestr/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively convey exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program interactive, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, commands use may called something show w show c; even mouse-clicks menu items–whatever suits program. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. sample; alter names: General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. Gnomovision version 69, Copyright (C) year name of author Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'. This is free software, and you are welcome to redistribute it under certain conditions; type `show c' for details. Yoyodyne, Inc., hereby disclaims all copyright interest in the program `Gnomovision' (which makes passes at compilers) written by James Hacker.  <signature of Ty Coon>, 1 April 1989 Ty Coon, President of Vice"},{"path":"https://jan-imbi.github.io/adestr/articles/Introduction.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Introduction to adestr","text":"package implements methods evaluate performance characteristics various point interval estimators adaptive two-stage designs prespecified sample-size recalculation rules. , allows evaluation estimators real datasets, implements methods calculate p-values. Currently, works designs objects produced R-package adoptr, calculates optimal design parameters adaptive two-stage designs. can learn adoptr : kkmann.github.io/adoptr/.","code":""},{"path":"https://jan-imbi.github.io/adestr/articles/Introduction.html","id":"fitting-a-design-with-adoptr","dir":"Articles","previous_headings":"","what":"Fitting a design with adoptr","title":"Introduction to adestr","text":"order showcase capabilities package, need trial design first. refer example adoptr documentation . can read optimal adaptive designs fitted via adoptr package : kkmann.github.io/adoptr/articles/adoptr_jss.html. sake introduction, pre-computed version first example kkmann.github.io/adoptr/articles/adoptr.html provided package via get_example_design function.","code":"library(adestr) get_example_design(two_armed = TRUE) #> TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80>"},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/articles/Introduction.html","id":"evaluating-the-mean-squared-of-an-estimator","dir":"Articles","previous_headings":"Example","what":"Evaluating the mean squared of an estimator","title":"Introduction to adestr","text":"Now created optimal adaptive design, can investigate performance characteristics various estimators mean design. end, evaluate_estimator function can used. mean squared error sample mean depends true underlying value paramter \\(\\mu\\), course unknown. Therefore, may advisable use evaluate_estimator function array values \\(\\mu\\) investigate distributional properties estimator. following, MSE sample mean vs. weighted sample mean fixed weights plotted.","code":"evaluate_estimator(  score = MSE(),  estimator = SampleMean(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = 0.3,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                                           Sample mean #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.3 #> Results: #>  Expectation:                                                          0.3056727 #>  Bias:                                                               0.005672677 #>  Variance:                                                            0.03777784 #>  MSE:                                                                 0.03781002 mse_mle <- evaluate_estimator(   score = MSE(),   estimator = SampleMean(),   data_distribution = Normal(two_armed = TRUE),   design = get_example_design(two_armed = TRUE),   mu = seq(-0.75, 1.32, .03),   sigma = 1 ) mse_weighted_sample_means <- evaluate_estimator(   score = MSE(),   estimator = WeightedSampleMean(w1 = .8),   data_distribution = Normal(two_armed = TRUE),   design = get_example_design(two_armed = TRUE),   mu = seq(-0.75, 1.32, .03),   sigma = 1 ) plot(c(mse_mle, mse_weighted_sample_means))"},{"path":"https://jan-imbi.github.io/adestr/articles/Introduction.html","id":"analyzing-datasets","dir":"Articles","previous_headings":"Example","what":"Analyzing datasets","title":"Introduction to adestr","text":"Next, let us look package can used calculate estimates data collected. first stage data trial might look like : results suggest recruiting 23 patients per group second stage. simulate 47 patients per group: Now, can use analyze function evaluate selection estimators complete dataset: estimates presented difference means two normal distributions. Keep mind difference \\(\\mu=0.3\\) used simulation. Note median unbiased estimator performs well particular example, universally true.","code":"set.seed(321) dat <- data.frame(  endpoint = c(rnorm(56, .3, 1), rnorm(56, 0, 1)),  group = factor(rep(c(\"trt\", \"ctl\"),                     c(56,56)), levels = c(\"trt\", \"ctl\")),  stage = rep(1, 112) ) head(dat) #>      endpoint group stage #> 1  2.00490322   trt     1 #> 2 -0.41203856   trt     1 #> 3  0.02201509   trt     1 #> 4  0.18035098   trt     1 #> 5  0.17603938   trt     1 #> 6  0.56818377   trt     1 analyze(data = dat,         statistics = list(),         data_distribution = Normal(two_armed = TRUE),         design = get_example_design(two_armed = TRUE),         sigma = 1) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Observed number of stages:                                                     1 #> Observed n1 (group 1)                                                         56 #> Observed n1 (group 2)                                                         56 #> Observed n1 (total)                                                          112 #> Z1                                                                          1.75 #> Interim decision:                                       continue to second stage #> Calculated n2(Z1) (per group)                                           46.99923 #> Calculated c2(Z1)                                                           1.14 dat <- rbind(dat,              data.frame(                endpoint = c(rnorm(47, .3, 1), rnorm(47, 0, 1)),                group = factor(rep(c(\"trt\", \"ctl\"),                                   c(47, 47)), levels = c(\"trt\", \"ctl\")),                stage = rep(2, 94)              )) analyze(  data = dat,  statistics = c(    SampleMean(),    BiasReduced(),    PseudoRaoBlackwell(),    MedianUnbiasedStagewiseCombinationFunctionOrdering(),    StagewiseCombinationFunctionOrderingCI(),    StagewiseCombinationFunctionOrderingPValue()    ),  data_distribution = Normal(two_armed = TRUE),  sigma = 1,  design = get_example_design(two_armed = TRUE) ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Observed number of stages:                                                     2 #> Observed n1 (group 1)                                                         56 #> Observed n1 (group 2)                                                         56 #> Observed n1 (total)                                                          112 #> Z1                                                                          1.75 #> Interim decision:                                       continue to second stage #> Calculated n2(Z1) (per group)                                           46.99923 #> Calculated c2(Z1)                                                           1.14 #> Observed n2 (group 1)                                                         47 #> Observed n2 (group 2)                                                         47 #> Observed n2 (in total)                                                        94 #> Z2                                                                          2.71 #> Final test decision:                                                 reject null #>  #> Stage 2 results: #>  Sample mean:                                                           0.434684 #>  Bias reduced MLE (iterations=1):                                      0.4221533 #>  Pseudo Rao-Blackwellized:                                             0.2658506 #>  Median unbiased (SWCF ordering):                                      0.3047428 #>  SWCF ordering CI:                                       [0.04435513, 0.5484439] #>  SWCF ordering p-value:                                               0.01097266"},{"path":"https://jan-imbi.github.io/adestr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jan Meis. Author, maintainer. Martin Maechler. Copyright holder.            Original author monoSpl.c ('stats' package).","code":""},{"path":"https://jan-imbi.github.io/adestr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Meis J (2024). adestr: Estimation Optimal Adaptive Two-Stage Designs. R package version 0.5.1, https://jan-imbi.github.io/adestr/.","code":"@Manual{,   title = {adestr: Estimation in Optimal Adaptive Two-Stage Designs},   author = {Jan Meis},   year = {2024},   note = {R package version 0.5.1},   url = {https://jan-imbi.github.io/adestr/}, }"},{"path":"https://jan-imbi.github.io/adestr/index.html","id":"adestr-","dir":"","previous_headings":"","what":"Estimation in Optimal Adaptive Two-Stage Designs","title":"Estimation in Optimal Adaptive Two-Stage Designs","text":"package implements methods evaluate performance characteristics various point interval estimators adaptive two-stage designs prespecified sample-size recalculation rules. , allows evaluation estimators real datasets, implements methods calculate p-values. Currently, works designs objects produced R-package adoptr, calculates optimal design parameters adaptive two-stage designs.","code":""},{"path":"https://jan-imbi.github.io/adestr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Estimation in Optimal Adaptive Two-Stage Designs","text":"can install development version adestr typing R console.","code":"remotes::install_github(\"https://github.com/jan-imbi/adestr\")"},{"path":"https://jan-imbi.github.io/adestr/index.html","id":"information-for-reviewers","dir":"","previous_headings":"","what":"Information for reviewers","title":"Estimation in Optimal Adaptive Two-Stage Designs","text":"scripts reproduce results paper can found /data/code/ directory repository. results located /data/ directory. easiest way inspect results clone repository.","code":""},{"path":"https://jan-imbi.github.io/adestr/index.html","id":"general-example-for-usage-of-the-package","dir":"","previous_headings":"","what":"General example for usage of the package","title":"Estimation in Optimal Adaptive Two-Stage Designs","text":"quick example showing capabilities adestr. First, load adestr: , can evaluate performance estimator like :  can analyze dataset like :","code":"library(adestr) evaluate_estimator(  score = MSE(),  estimator = SampleMean(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(),  mu = c(0, 0.3, 0.6),  sigma = 1 ) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                                           Sample mean #> Assumed sigma:                                                                 1 #> Assumed mu:                                                          0.0 0.3 0.6 #> Results: #>  Expectation:                                   -0.0352411  0.2816994  0.6355803 #>  Bias:                                       -0.03524110 -0.01830056  0.03558030 #>  Variance:                                      0.05558372 0.07330105 0.06590990 #>  MSE:                                           0.05682565 0.07363596 0.06717585  evaluate_estimator(  score = MSE(),  estimator = SampleMean(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(),  mu = seq(-0.7, 1.5, .05),  sigma = 1 ) |>    plot() set.seed(321) dat <- data.frame(  endpoint = c(rnorm(28, .2, 1), rnorm(28, 0, 1),               rnorm(23, .2, 1), rnorm(23, 0, 1)),  group = factor(rep(c(\"ctl\", \"trt\", \"ctl\", \"trt\"),                     c(28,28,23,23))),  stage = rep(c(1L, 2L), c(56, 46)) ) analyze(  data = dat,  statistics = get_example_statistics(),  data_distribution = Normal(two_armed = TRUE),  sigma = 1,  design = get_example_design() ) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                             Normal<two-armed> #> Observed number of stages:                                                     2 #> Observed n1 (group 1)                                                         28 #> Observed n1 (group 2)                                                         28 #> Observed n1 (total)                                                           56 #> Z1                                                                          1.75 #> Interim decision:                                       continue to second stage #> Calculated n2(Z1) (per group)                                           23.49151 #> Calculated c2(Z1)                                                           1.14 #> Observed n2 (group 1)                                                         23 #> Observed n2 (group 2)                                                         23 #> Observed n2 (in total)                                                        46 #> Z2                                                                          2.12 #> Final test decision:                                                 reject null #>  #> Stage 2 results: #>  Sample mean:                                                          0.5389012 #>  Pseudo Rao-Blackwellized:                                             0.3632916 #>  Median unbiased (LR test ordering):                                   0.5069941 #>  Bias reduced MLE (iterations=1):                                      0.5253942 #>  SWCF ordering CI:                                       [0.06264641, 0.7429735] #>  LR test ordering CI:                                       [0.2509094, 0.81829] #>  SWCF ordering p-value:                                               0.01097483 #>  LR test ordering p-value:                                          6.653031e-05"},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Performance scores for point and interval estimators — EstimatorScore-class","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"classes encode various metrics can used evaluate performance characteristics point interval estimators.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"","code":"Expectation()  Bias()  Variance()  MSE()  OverestimationProbability()  Coverage()  SoftCoverage(shrinkage = 1)  Width()  TestAgreement()  Centrality(interval = NULL)"},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"shrinkage shrinkage factor bump function. interval confidence interval respect centrality point estimator evaluated.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"object class EstimatorScore. class signals object can used evaluate_estimator function.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"label name performance score. Used printing methods.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"details-on-the-implemented-estimators","dir":"Reference","previous_headings":"","what":"Details on the implemented estimators","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"following, precise definitions performance scores implemented adestr given. end, let \\(\\hat{\\mu}\\) denote point estimator, (\\(\\hat{l}\\), \\(\\hat{u}\\)) interval estimator, denote expected value random variable \\(\\mathbb{E}\\), probability event \\(P\\), let \\(\\mu\\) real value underlying parameter estimated.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"scores-for-point-estimators-pointestimatorscore-","dir":"Reference","previous_headings":"","what":"Scores for point estimators (PointEstimatorScore):","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"Expectation(): \\(\\mathbb{E}[\\hat{\\mu}]\\) Bias(): \\(\\mathbb{E}[\\hat{\\mu} - \\mu]\\) Variance(): \\(\\mathbb{E}[(\\hat{\\mu} - \\mathbb{E}[\\hat{\\mu}])^2]\\) MSE(): \\(\\mathbb{E}[(\\hat{\\mu} - mu)^2]\\) OverestimationProbability(): \\(P(\\hat{\\mu} > \\mu)\\) Centrality(interval): \\(\\mathbb{E}[(\\hat{\\mu} - \\hat{l}) + (\\hat{\\mu} - \\hat{u}]\\)","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"scores-for-confidence-intervals-intervalestimatorscore-","dir":"Reference","previous_headings":"","what":"Scores for confidence intervals (IntervalEstimatorScore):","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"Coverage(): \\(P(\\hat{l} \\leq \\mu \\leq \\hat{u})\\) Width(): \\(\\mathbb{E}[\\hat{u} - \\hat{l}]\\) TestAgreement(): \\(P\\left( \\left(\\{0 < \\hat{l} \\text{ } (c_{1, e} < Z_1 \\text{ } c_{2}(Z_1) < Z_2 ) \\right) \\text{ } \\left(\\{\\hat{l} \\leq 0  \\text{ } ( Z_1 < c_{1, f} \\text{ } Z_2 \\leq c_{2}(Z_1))\\}\\right)\\right)\\)","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"","code":"evaluate_estimator(   score = MSE(),   estimator = SampleMean(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu = c(0, 0.3, 0.6),   sigma = 1,   exact = FALSE ) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Estimator:                                                           Sample mean #> Assumed sigma:                                                                 1 #> Assumed mu:                                                          0.0 0.3 0.6 #> Results: #>  Expectation:                                -0.02491922  0.30567290  0.62041636 #>  Bias:                                    -0.024919220  0.005672903  0.020416356 #>  Variance:                                      0.02779122 0.03777824 0.02790974 #>  MSE:                                           0.02841219 0.03781042 0.02832657 #>   evaluate_estimator(   score = Coverage(),   estimator = StagewiseCombinationFunctionOrderingCI(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu = c(0, 0.3),   sigma = 1,   exact = FALSE ) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Estimator:                                                      SWCF ordering CI #> Assumed sigma:                                                                 1 #> Assumed mu:                                                              0.0 0.3 #> Results: #>  Coverage:                                                   0.9500681 0.9499744 #>"},{"path":"https://jan-imbi.github.io/adestr/reference/IntervalEstimator-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Interval estimators — IntervalEstimator-class","title":"Interval estimators — IntervalEstimator-class","text":"parent class confidence intervals implemented package. Currently, confidence intervals parameter \\(\\mu\\) normal distribution implemented. Details methods calculating confidence intervals can found (upcoming paper).","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/IntervalEstimator-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interval estimators — IntervalEstimator-class","text":"","code":"IntervalEstimator(two_sided, l1, u1, l2, u2, label)  RepeatedCI(two_sided = TRUE)  StagewiseCombinationFunctionOrderingCI(two_sided = TRUE)  MLEOrderingCI(two_sided = TRUE)  LikelihoodRatioOrderingCI(two_sided = TRUE)  ScoreTestOrderingCI(two_sided = TRUE)  NeymanPearsonOrderingCI(two_sided = TRUE, mu0 = 0, mu1 = 0.4)  NaiveCI(two_sided = TRUE)"},{"path":"https://jan-imbi.github.io/adestr/reference/IntervalEstimator-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interval estimators — IntervalEstimator-class","text":"two_sided logical indicating whether confidence interval two-sided. l1 functional representation lower boundary interval early futility efficacy regions. u1 functional representation upper boundary interval early futility efficacy regions. l2 functional representation lower boundary interval continuation region. u2 functional representation upper boundary interval continuation region. label name estimator. Used printing methods. mu0 expected value normal distribution null hypothesis. mu1 expected value normal distribution null hypothesis.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/IntervalEstimator-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interval estimators — IntervalEstimator-class","text":"object class IntervalEstimator. class signals object can supplied evaluate_estimator analyze functions.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/IntervalEstimator-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Interval estimators — IntervalEstimator-class","text":"implemented confidence intervals : MLEOrderingCI() LikelihoodRatioOrderingCI() ScoreTestOrderingCI() StagewiseCombinationFunctionOrderingCI() confidence intervals constructed specifying ordering sample space finding value \\(\\mu\\), observed sample \\(\\alpha/2\\) ((\\(1-\\alpha/2\\))) quantile sample space according chosen ordering. implemented orderings based work presented (Emerson Fleming 1990) , (Sections 8.4 Jennison Turnbull 1999) , (Sections 4.1.1 8.2.1 Wassmer Brannath 2016) .","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/IntervalEstimator-class.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Interval estimators — IntervalEstimator-class","text":"Emerson SS, Fleming TR (1990). “Parameter estimation following group sequential hypothesis testing.” Biometrika, 77(4), 875--892. doi:10.2307/2337110 . Jennison C, Turnbull BW (1999). Group Sequential Methods Applications Clinical Trials, 1 edition. Chapman Hall/CRC., New York. doi:10.1201/9780367805326 . Wassmer G, Brannath W (2016). Group Sequential Confirmatory Adaptive Designs Clinical Trials, 1 edition. Springer, Cham, Switzerland. doi:10.1007/978-3-319-32562-0 .","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/IntervalEstimator-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interval estimators — IntervalEstimator-class","text":"","code":"# This is the definition of the 'naive' confidence interval for one-armed trials IntervalEstimator(   two_sided = TRUE,   l1 = \\(smean1, n1, sigma, ...) smean1 - qnorm(.95, sd = sigma/sqrt(n1)),   u1 = \\(smean1, n1, sigma, ...) smean1 + qnorm(.95, sd = sigma/sqrt(n1)),   l2 = \\(smean1, smean2, n1, n2, sigma, ...) smean2 - qnorm(.95, sd = sigma/sqrt(n1 + n2)),   u2 = \\(smean1, smean2, n1, n2, sigma, ...) smean2 + qnorm(.95, sd = sigma/sqrt(n1 + n2)),   label=\"My custom CI\") #> My custom CI"},{"path":"https://jan-imbi.github.io/adestr/reference/Normal.html","id":null,"dir":"Reference","previous_headings":"","what":"Normally distributed data with known variance — Normal","title":"Normally distributed data with known variance — Normal","text":"function creates object representing distributional assumptions data: normally distributed outcomes sample trial one two arms (depending value parameter two_armed), assumption known variance.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/Normal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normally distributed data with known variance — Normal","text":"","code":"Normal(two_armed = TRUE)"},{"path":"https://jan-imbi.github.io/adestr/reference/Normal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normally distributed data with known variance — Normal","text":"two_armed (logical) determines whether one two-armed trials assumed.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/Normal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normally distributed data with known variance — Normal","text":"object class Normal. object encodes distributional assumptions data usage functions evaluate_estimator analyze.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/Normal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Normally distributed data with known variance — Normal","text":"","code":"evaluate_estimator(   score = MSE(),   estimator = SampleMean(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu = c(0, 0.3, 0.6),   sigma = 1,   exact = FALSE ) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Estimator:                                                           Sample mean #> Assumed sigma:                                                                 1 #> Assumed mu:                                                          0.0 0.3 0.6 #> Results: #>  Expectation:                                -0.02491922  0.30567290  0.62041636 #>  Bias:                                    -0.024919220  0.005672903  0.020416356 #>  Variance:                                      0.02779122 0.03777824 0.02790974 #>  MSE:                                           0.02841219 0.03781042 0.02832657 #>"},{"path":"https://jan-imbi.github.io/adestr/reference/NormalPrior.html","id":null,"dir":"Reference","previous_headings":"","what":"Normal prior distribution for the parameter mu — NormalPrior","title":"Normal prior distribution for the parameter mu — NormalPrior","text":"Normal prior distribution parameter mu","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/NormalPrior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normal prior distribution for the parameter mu — NormalPrior","text":"","code":"NormalPrior(mu = 0, sigma = 1)"},{"path":"https://jan-imbi.github.io/adestr/reference/NormalPrior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normal prior distribution for the parameter mu — NormalPrior","text":"mu mean prior distribution. sigma standard deviation prior distribution.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/NormalPrior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normal prior distribution for the parameter mu — NormalPrior","text":"object class NormalPrior. object can supplied argument mu evaluate_estimator function calculate performance scores weighted prior.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/NormalPrior.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Normal prior distribution for the parameter mu — NormalPrior","text":"","code":"NormalPrior(mu = 0, sigma = 1) #> NormalPrior<mu=0;sigma=1>"},{"path":"https://jan-imbi.github.io/adestr/reference/PValue-class.html","id":null,"dir":"Reference","previous_headings":"","what":"P-values — PValue-class","title":"P-values — PValue-class","text":"parent class p-values implemented package. Details methods calculating p-values can found (upcoming paper).","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PValue-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"P-values — PValue-class","text":"","code":"PValue(g1, g2, label)  LinearShiftRepeatedPValue(wc1f = 0, wc1e = 1/2, wc2 = 1/2)  MLEOrderingPValue()  LikelihoodRatioOrderingPValue()  ScoreTestOrderingPValue()  StagewiseCombinationFunctionOrderingPValue()  NeymanPearsonOrderingPValue(mu0 = 0, mu1 = 0.4)  NaivePValue()"},{"path":"https://jan-imbi.github.io/adestr/reference/PValue-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"P-values — PValue-class","text":"g1 functional representation p-value early futility efficacy regions. g2 functional representation p-value continuation region. label name p-value. Used printing methods. wc1f slope futility boundary change. wc1e slope efficacy boundary change. wc2 slope c2 boundary change. mu0 expected value normal distribution null hypothesis. mu1 expected value normal distribution null hypothesis.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PValue-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"P-values — PValue-class","text":"object class PValue. class signals object can supplied analyze function.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PValue-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"P-values — PValue-class","text":"implemented p-values : MLEOrderingPValue() LikelihoodRatioOrderingPValue() ScoreTestOrderingPValue() StagewiseCombinationFunctionOrderingPValue() p-values calculated specifying ordering sample space calculating probability random sample null hypothesis larger observed sample. implemented orderings based work presented (Emerson Fleming 1990) , (Sections 8.4 Jennison Turnbull 1999) , (Sections 4.1.1 8.2.1 Wassmer Brannath 2016) .","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PValue-class.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"P-values — PValue-class","text":"Emerson SS, Fleming TR (1990). “Parameter estimation following group sequential hypothesis testing.” Biometrika, 77(4), 875--892. doi:10.2307/2337110 . Jennison C, Turnbull BW (1999). Group Sequential Methods Applications Clinical Trials, 1 edition. Chapman Hall/CRC., New York. doi:10.1201/9780367805326 . Wassmer G, Brannath W (2016). Group Sequential Confirmatory Adaptive Designs Clinical Trials, 1 edition. Springer, Cham, Switzerland. doi:10.1007/978-3-319-32562-0 .","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/PValue-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"P-values — PValue-class","text":"","code":"# This is the definition of a 'naive' p-value based on a Z-test for a one-armed trial PValue(   g1 = \\(smean1, n1, sigma, ...) pnorm(smean1*sqrt(n1)/sigma, lower.tail=FALSE),   g2 = \\(smean1, smean2, n1, n2, ...) pnorm((n1 * smean1 + n2 * smean2)/(n1 + n2) *                                         sqrt(n1+n2)/sigma, lower.tail=FALSE),   label=\"My custom p-value\") #> My custom p-value"},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Point estimators — PointEstimator-class","title":"Point estimators — PointEstimator-class","text":"parent class point estimators implemented package. Currently, estimators parameter \\(\\mu\\) normal distribution implemented.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Point estimators — PointEstimator-class","text":"","code":"PointEstimator(g1, g2, label)  SampleMean()  FirstStageSampleMean()  WeightedSampleMean(w1 = 0.5)  AdaptivelyWeightedSampleMean(w1 = 1/sqrt(2))  MinimizePeakVariance()  BiasReduced(iterations = 1L)  RaoBlackwell()  PseudoRaoBlackwell()  MidpointStagewiseCombinationFunctionOrderingCI()  MidpointMLEOrderingCI()  MidpointLikelihoodRatioOrderingCI()  MidpointScoreTestOrderingCI()  MidpointNeymanPearsonOrderingCI()  MedianUnbiasedStagewiseCombinationFunctionOrdering()  MedianUnbiasedMLEOrdering()  MedianUnbiasedLikelihoodRatioOrdering()  MedianUnbiasedScoreTestOrdering()  MedianUnbiasedNeymanPearsonOrdering(mu0 = 0, mu1 = 0.4)"},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Point estimators — PointEstimator-class","text":"g1 functional representation estimator early futility efficacy regions. g2 functional representation estimator continuation region. label name estimator. Used printing methods. w1 weight first-stage data. iterations number bias reduction iterations. Defaults 1. mu0 expected value normal distribution null hypothesis. mu1 expected value normal distribution null hypothesis.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Point estimators — PointEstimator-class","text":"object class PointEstimator. class signals object can supplied evaluate_estimator analyze functions.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Point estimators — PointEstimator-class","text":"Details point estimators can found (upcoming paper).","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"sample-mean-samplemean-","dir":"Reference","previous_headings":"","what":"Sample Mean (SampleMean())","title":"Point estimators — PointEstimator-class","text":"sample mean maximum likelihood estimator mean probably 'straightforward' implemented estimators.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"fixed-weighted-sample-means-weightedsamplemean-","dir":"Reference","previous_headings":"","what":"Fixed weighted sample means (WeightedSampleMean())","title":"Point estimators — PointEstimator-class","text":"first- second-stage (available) sample means combined via fixed, predefined weights. See (Brannath et al. 2006)  (Section 8.3.2 Wassmer Brannath 2016) .","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"adaptively-weighted-sample-means-adaptivelyweightedsamplemean-","dir":"Reference","previous_headings":"","what":"Adaptively weighted sample means (AdaptivelyWeightedSampleMean())","title":"Point estimators — PointEstimator-class","text":"first- second-stage (available) sample means combined via combination fixed adaptively modified weights depend standard error. See (Section 8.3.4 Wassmer Brannath 2016) .","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"minimizing-peak-variance-in-adaptively-weighted-sample-means-minimizepeakvariance-","dir":"Reference","previous_headings":"","what":"Minimizing peak variance in adaptively weighted sample means (MinimizePeakVariance())","title":"Point estimators — PointEstimator-class","text":"estimator, weights adaptively weighted sample mean chosen minimize variance estimator value \\(\\mu\\) maximizes expected sample size.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"-pseudo-rao-blackwell-estimators-raoblackwell-and-pseudoraoblackwell-","dir":"Reference","previous_headings":"","what":"(Pseudo) Rao-Blackwell estimators (RaoBlackwell and PseudoRaoBlackwell)","title":"Point estimators — PointEstimator-class","text":"conditional expectation first-stage sample mean given overall sample mean second-stage sample size. See (Emerson Kittelson 1997) .","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"a-bias-reduced-estimator-biasreduced-","dir":"Reference","previous_headings":"","what":"A bias-reduced estimator (BiasReduced())","title":"Point estimators — PointEstimator-class","text":"estimator calculated subtracting estimate bias MLE. See (Whitehead 1986) .","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"median-unbiased-estimators","dir":"Reference","previous_headings":"","what":"Median-unbiased estimators","title":"Point estimators — PointEstimator-class","text":"implemented median-unbiased estimators : MedianUnbiasedMLEOrdering() MedianUnbiasedLikelihoodRatioOrdering() MedianUnbiasedScoreTestOrdering() MedianUnbiasedStagewiseCombinationFunctionOrdering() estimators constructed specifying ordering sample space finding value \\(\\mu\\), observed sample median sample space according chosen ordering. implemented orderings based work presented (Emerson Fleming 1990) , (Sections 8.4 Jennison Turnbull 1999) , (Sections 4.1.1 8.2.1 Wassmer Brannath 2016) .","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Point estimators — PointEstimator-class","text":"Brannath W, König F, Bauer P (2006). “Estimation flexible two stage designs.” Statistics Medicine, 25(19), 3366-3381. doi:10.1002/sim.2258 . Emerson SS, Fleming TR (1990). “Parameter estimation following group sequential hypothesis testing.” Biometrika, 77(4), 875--892. doi:10.2307/2337110 . Emerson SS, Kittelson JM (1997). “computationally simpler algorithm UMVUE normal mean following group sequential trial.” Biometrics, 53(1), 365--369. doi:10.2307/2533122 . Jennison C, Turnbull BW (1999). Group Sequential Methods Applications Clinical Trials, 1 edition. Chapman Hall/CRC., New York. doi:10.1201/9780367805326 . Wassmer G, Brannath W (2016). Group Sequential Confirmatory Adaptive Designs Clinical Trials, 1 edition. Springer, Cham, Switzerland. doi:10.1007/978-3-319-32562-0 . Whitehead J (1986). “bias maximum likelihood estimation following sequential test.” Biometrika, 73(3), 573--581. doi:10.2307/2336521 .","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Point estimators — PointEstimator-class","text":"","code":"PointEstimator(g1 = \\(smean1, ...) smean1,g2 = \\(smean2, ...) smean2, label=\"My custom estimator\") #> My custom estimator"},{"path":"https://jan-imbi.github.io/adestr/reference/Statistic-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Statistics and Estimators of the adestr package — Statistic-class","title":"Statistics and Estimators of the adestr package — Statistic-class","text":"Statistic class parent class classes Estimator PValue. Estimator class parent classes PointEstimator ConfidenceInterval.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/Statistic-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Statistics and Estimators of the adestr package — Statistic-class","text":"label name statistic. Used printing methods.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/Statistic-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Statistics and Estimators of the adestr package — Statistic-class","text":"object class Statistic. class signals object can supplied analyze function.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/Statistic-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Statistics and Estimators of the adestr package — Statistic-class","text":"function analyze can used calculate value Statistic given dataset. function evaluate_estimator can used evaluate distributional quantities Estimator like MSE PointEstimator Coverage ConfidenceInterval.","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/Student.html","id":null,"dir":"Reference","previous_headings":"","what":"Normally distributed data with unknown variance — Student","title":"Normally distributed data with unknown variance — Student","text":"function creates object representing distributional assumptions data: normally distributed outcomes sample trial one two arms (depending value parameter two_armed), assumption known variance.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/Student.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normally distributed data with unknown variance — Student","text":"","code":"Student(two_armed = TRUE)"},{"path":"https://jan-imbi.github.io/adestr/reference/Student.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normally distributed data with unknown variance — Student","text":"two_armed (logical) determines whether one two-armed trials assumed.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/Student.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normally distributed data with unknown variance — Student","text":"object class Student. object encodes distributional assumptions data usage functions evaluate_estimator analyze.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/Student.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Normally distributed data with unknown variance — Student","text":"","code":"evaluate_estimator(   score = MSE(),   estimator = SampleMean(),   data_distribution = Student(FALSE),   design = get_example_design(),   mu = c(0, 0.3, 0.6),   sigma = 1,   exact = FALSE ) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                         Student<single-armed> #> Estimator:                                                           Sample mean #> Assumed sigma:                                                                 1 #> Assumed mu:                                                          0.0 0.3 0.6 #> Results: #>  Expectation:                                -0.01713719  0.29942959  0.63246965 #>  Bias:                                 -0.0171371870 -0.0005704083  0.0324696452 #>  Variance:                                      0.02773638 0.03751533 0.02773868 #>  MSE:                                           0.02803007 0.03751566 0.02879296 #>"},{"path":"https://jan-imbi.github.io/adestr/reference/TwoStageDesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Re-export of two-stage design class — TwoStageDesign-class","title":"Re-export of two-stage design class — TwoStageDesign-class","text":"re-export TwoStageDesign class adoptr (Kunzmann et al. 2021)  package.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/TwoStageDesign-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Re-export of two-stage design class — TwoStageDesign-class","text":"function currently re-exported resolve CRAN conflicts. details, please refer paper (Kunzmann et al. 2021)  original github repository https://github.com/kkmann/adoptr.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/TwoStageDesign-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Re-export of two-stage design class — TwoStageDesign-class","text":"n1 (numeric) first-stage sample size. c1f (numeric) first-stage futility boundary. c1e (numeric) first-stage early efficacy boundary. n2_pivots (numeric) vector containing values n2 spline function. c2_pivots (numeric) vector containing values second-stage rejection boundary spline c2 x1_norm_pivots (numeric) vector containing x-axis (z-sclae) points n2 c2 splines weights (numeric) vector containing integration weights tunable (logical) vector determining whether desing paramters optimized","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/TwoStageDesignWithCache.html","id":null,"dir":"Reference","previous_headings":"","what":"TwoStageDesignWithCache constructor function — TwoStageDesignWithCache","title":"TwoStageDesignWithCache constructor function — TwoStageDesignWithCache","text":"Creates object class TwoStageDesignWithCache. object stores precalculated spline paramters n2 c2 functions, allows quicker evaluation.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/TwoStageDesignWithCache.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"TwoStageDesignWithCache constructor function — TwoStageDesignWithCache","text":"","code":"TwoStageDesignWithCache(design)"},{"path":"https://jan-imbi.github.io/adestr/reference/TwoStageDesignWithCache.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"TwoStageDesignWithCache constructor function — TwoStageDesignWithCache","text":"design object class TwoStageDesign","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/UniformPrior.html","id":null,"dir":"Reference","previous_headings":"","what":"Uniform prior distribution for the parameter mu — UniformPrior","title":"Uniform prior distribution for the parameter mu — UniformPrior","text":"Uniform prior distribution parameter mu","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/UniformPrior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Uniform prior distribution for the parameter mu — UniformPrior","text":"","code":"UniformPrior(min = -1, max = 1)"},{"path":"https://jan-imbi.github.io/adestr/reference/UniformPrior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Uniform prior distribution for the parameter mu — UniformPrior","text":"min minimum support interval. max maximum support interval.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/UniformPrior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Uniform prior distribution for the parameter mu — UniformPrior","text":"object class UniformPrior. object can supplied argument mu evaluate_estimator function calculate performance scores weighted prior.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/UniformPrior.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Uniform prior distribution for the parameter mu — UniformPrior","text":"","code":"UniformPrior(min = -1, max = 1) #> UniformPrior<min=-1;max=1>"},{"path":"https://jan-imbi.github.io/adestr/reference/adestr.html","id":null,"dir":"Reference","previous_headings":"","what":"adestr — adestr","title":"adestr — adestr","text":"Point estimates, confidence intervals, p-values optimal adaptive two-stage designs.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/adestr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"adestr — adestr","text":"package implements methods evaluate performance characteristics various point interval estimators optimal adaptive two-stage designs. Specifically, package written interface trial designs created adoptr package (Kunzmann et al. 2021; Pilz et al. 2021) . Apart priori evaluation performance characteristics, package also allows calculation values estimators given real datasets, implements methods calculate p-values.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/adestr.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"adestr — adestr","text":"Kunzmann K, Pilz M, Herrmann C, Rauch G, Kieser M (2021). “adoptr package: Adaptive Optimal Designs Clinical Trials R.” Journal Statistical Software, 98(9), 1–21. doi:10.18637/jss.v098.i09 . Pilz M, Kunzmann K, Herrmann C, Rauch G, Kieser M (2021). “Optimal planning adaptive two-stage designs.” Statistics Medicine, 40(13), 3196-3213. doi:10.1002/sim.8953 .","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/adestr.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"adestr — adestr","text":"Maintainer: Jan Meis meis@imbi.uni-heidelberg.de (ORCID) contributors: Martin Maechler maechler@stat.math.ethz.ch (ORCID) (Original author monoSpl.c ('stats' package).) [copyright holder]","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/analyze.html","id":null,"dir":"Reference","previous_headings":"","what":"Analyze a dataset — analyze","title":"Analyze a dataset — analyze","text":"analyze function can used calculate values list point estimators, confidence intervals, p-values given dataset.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/analyze.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analyze a dataset — analyze","text":"","code":"analyze(   data,   statistics = list(),   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for data.frame analyze(   data,   statistics = list(),   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )"},{"path":"https://jan-imbi.github.io/adestr/reference/analyze.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Analyze a dataset — analyze","text":"data data.frame containing data analyzed. statistics list objects class PointEstimator, ConfidenceInterval PValue. data_distribution object class Normal Student. use_full_twoarm_sampling_distribution logical indicating whether estimator intended used full sampling distribution two-armed trial. design object class TwoStageDesign. sigma assumed standard deviation. exact logical indicating usage exact n2 function.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/analyze.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Analyze a dataset — analyze","text":"Results object containing values statistics applied data.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/analyze.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Analyze a dataset — analyze","text":"Note adestr, statistics codes functions stage-wise sample means (stage-wise sample variances data_distribution Student). first-step, data summarized produce parameters. , list statistics evaluated values parameters. output analyze function also displays information hypothesis test interim decision. statistics list empty, information displayed.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/analyze.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Analyze a dataset — analyze","text":"","code":"set.seed(123) dat <- data.frame(   endpoint = c(rnorm(28, 0.3)),   stage = rep(1, 28) ) analyze(data = dat,         statistics = list(),         data_distribution = Normal(FALSE),         design = get_example_design(),         sigma = 1) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Observed number of stages:                                                     1 #> Observed n1 (total)                                                           28 #> Z1                                                                           1.3 #> Interim decision:                                       continue to second stage #> Calculated n2(Z1) (per group)                                           32.21129 #> Calculated c2(Z1)                                                           1.71 #>   # The results suggest recruiting 32 patients for the second stage dat <- rbind(   dat,   data.frame(     endpoint = rnorm(32, mean = 0.3),     stage = rep(2, 32))) analyze(data = dat,         statistics = get_example_statistics(),         data_distribution = Normal(FALSE),         design = get_example_design(),         sigma = 1) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Observed number of stages:                                                     2 #> Observed n1 (total)                                                           28 #> Z1                                                                           1.3 #> Interim decision:                                       continue to second stage #> Calculated n2(Z1) (per group)                                           32.21129 #> Calculated c2(Z1)                                                           1.71 #> Observed n2 (in total)                                                        32 #> Z2                                                                          2.66 #> Final test decision:                                                 reject null #>  #> Stage 2 results: #>  Sample mean:                                                          0.3656173 #>  Pseudo Rao-Blackwellized:                                             0.3135628 #>  Median unbiased (LR test ordering):                                   0.3420742 #>  Bias reduced MLE (iterations=1):                                       0.357214 #>  SWCF ordering CI:                                       [0.04664821, 0.6142449] #>  LR test ordering CI:                                    [0.08992822, 0.6106096] #>  SWCF ordering p-value:                                               0.01321363 #>  LR test ordering p-value:                                           0.003551316 #>"},{"path":"https://jan-imbi.github.io/adestr/reference/c-EstimatorScoreResult-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResult-method","title":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResult-method","text":"Creates object class EstimatoreScoreResultList, basically list respective EstimatoreScoreResult objects.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/c-EstimatorScoreResult-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResult-method","text":"","code":"# S4 method for EstimatorScoreResult c(x, ...)"},{"path":"https://jan-imbi.github.io/adestr/reference/c-EstimatorScoreResult-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResult-method","text":"x object class EstimatorScoreResult. ... additional arguments passed along list function","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/c-EstimatorScoreResult-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResult-method","text":"object class EstimatoreScoreResultList.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/c-EstimatorScoreResultList-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResultList-method","title":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResultList-method","text":"Creates object class EstimatoreScoreResultList, basically list respective EstimatoreScoreResult objects.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/c-EstimatorScoreResultList-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResultList-method","text":"","code":"# S4 method for EstimatorScoreResultList c(x, ...)"},{"path":"https://jan-imbi.github.io/adestr/reference/c-EstimatorScoreResultList-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResultList-method","text":"x object class EstimatorScoreResult. ... additional arguments passed along list function","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/c-EstimatorScoreResultList-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResultList-method","text":"object class EstimatoreScoreResultList.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/c2_extrapol.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the second-stage critical value for a design with cached spline parameters — c2_extrapol","title":"Calculate the second-stage critical value for a design with cached spline parameters — c2_extrapol","text":"Also extrapolates results values outside [c1f, c1e].","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/c2_extrapol.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the second-stage critical value for a design with cached spline parameters — c2_extrapol","text":"","code":"c2_extrapol(design, x1)"},{"path":"https://jan-imbi.github.io/adestr/reference/c2_extrapol.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the second-stage critical value for a design with cached spline parameters — c2_extrapol","text":"design object class TwoStageDesignWithCache. x1 first-stage test statistic","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate performance characteristics of an estimator — evaluate_estimator-methods","title":"Evaluate performance characteristics of an estimator — evaluate_estimator-methods","text":"function evaluates EstimatorScore PointEstimator IntervalEstimator integrating sampling distribution.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate performance characteristics of an estimator — evaluate_estimator-methods","text":"","code":"# S4 method for PointEstimatorScore,IntervalEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for IntervalEstimatorScore,PointEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for list,Estimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for Expectation,PointEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for Bias,PointEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for Variance,PointEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for MSE,PointEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for OverestimationProbability,PointEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for Coverage,IntervalEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for SoftCoverage,IntervalEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for Width,IntervalEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for TestAgreement,IntervalEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for TestAgreement,PValue evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for Centrality,PointEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )"},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate performance characteristics of an estimator — evaluate_estimator-methods","text":"score performance measure evaluate. estimator object class PointEstimator, IntervalEstimator PValue. data_distribution object class Normal Student. use_full_twoarm_sampling_distribution logical indicating whether estimator intended used full sampling distribution two-armed trial. design object class TwoStageDesign. true_parameter true value parameter (used e.g. evaluating bias). mu expected value underlying normal distribution. sigma assumed standard deviation. tol relative tolerance. maxEval maximum number iterations. absError absolute tolerance. exact logical indicating usage exact n2 function. early_futility_part include early futility part integral. continuation_part include continuation part integral. early_efficacy_part include early efficacy part integral. conditional_integral treat integral conditional integral.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator-methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate performance characteristics of an estimator — evaluate_estimator-methods","text":"object class EstimatorScoreResult containing values evaluated EstimatorScore information setting calculated (e.g. estimator, data_distribution, design, mu, sigma).","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator-methods.html","id":"general","dir":"Reference","previous_headings":"","what":"General","title":"Evaluate performance characteristics of an estimator — evaluate_estimator-methods","text":"First, functional representation integrand created combining information EstimatorScore object (score) PointEstimator IntervalEstimator object (estimator). sampling distribution design determined TwoStageDesign object (design) DataDistribution object (data_distribution), well assumed parameters \\(\\mu\\) (mu) \\(\\sigma\\) (sigma). parameters control various details integration problem.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator-methods.html","id":"other-parameters","dir":"Reference","previous_headings":"","what":"Other parameters","title":"Evaluate performance characteristics of an estimator — evaluate_estimator-methods","text":"two-armed data_distribution, use_full_twoarm_sampling_distribution TRUE, sample means groups integrated independently. use_full_twoarm_sampling_distribution FALSE, difference sample means integrated. true_parameter controls parameters supposed estimated. usually mu, set sigma one interested estimating standard deviation. parameter exact set FALSE (default), continuous version second-stage sample-size function n2 used. Otherwise, integer valued version function used, though considerably slower. parameters early_futility_part, continuation_part early_efficacy_part control parts sample-space integrated (default TRUE). can used conjunction parameter conditional_integral, enables calculation expected value performance score conditional reaching selected integration regions. Lastly, paramters tol, maxEval, absError control integration accuracy. handed hcubature function.","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate performance characteristics of an estimator — evaluate_estimator-methods","text":"","code":"evaluate_estimator(   score = MSE(),   estimator = SampleMean(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu = c(0, 0.3, 0.6),   sigma = 1,   exact = FALSE ) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Estimator:                                                           Sample mean #> Assumed sigma:                                                                 1 #> Assumed mu:                                                          0.0 0.3 0.6 #> Results: #>  Expectation:                                -0.02491922  0.30567290  0.62041636 #>  Bias:                                    -0.024919220  0.005672903  0.020416356 #>  Variance:                                      0.02779122 0.03777824 0.02790974 #>  MSE:                                           0.02841219 0.03781042 0.02832657 #>   evaluate_estimator(   score = Coverage(),   estimator = StagewiseCombinationFunctionOrderingCI(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu = c(0, 0.3),   sigma = 1,   exact = FALSE ) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Estimator:                                                      SWCF ordering CI #> Assumed sigma:                                                                 1 #> Assumed mu:                                                              0.0 0.3 #> Results: #>  Coverage:                                                   0.9500681 0.9499744 #>"},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate performance characteristics of an estimator — evaluate_estimator","title":"Evaluate performance characteristics of an estimator — evaluate_estimator","text":"function evaluates EstimatorScore PointEstimator IntervalEstimator integrating sampling distribution.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate performance characteristics of an estimator — evaluate_estimator","text":"","code":"evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )"},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate performance characteristics of an estimator — evaluate_estimator","text":"score performance measure evaluate. estimator object class PointEstimator, IntervalEstimator PValue. data_distribution object class Normal Student. use_full_twoarm_sampling_distribution logical indicating whether estimator intended used full sampling distribution two-armed trial. design object class TwoStageDesign. true_parameter true value parameter (used e.g. evaluating bias). mu expected value underlying normal distribution. sigma assumed standard deviation. tol relative tolerance. maxEval maximum number iterations. absError absolute tolerance. exact logical indicating usage exact n2 function. early_futility_part include early futility part integral. continuation_part include continuation part integral. early_efficacy_part include early efficacy part integral. conditional_integral treat integral conditional integral.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate performance characteristics of an estimator — evaluate_estimator","text":"object class EstimatorScoreResult containing values evaluated EstimatorScore information setting calculated (e.g. estimator, data_distribution, design, mu, sigma).","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator.html","id":"general","dir":"Reference","previous_headings":"","what":"General","title":"Evaluate performance characteristics of an estimator — evaluate_estimator","text":"First, functional representation integrand created combining information EstimatorScore object (score) PointEstimator IntervalEstimator object (estimator). sampling distribution design determined TwoStageDesign object (design) DataDistribution object (data_distribution), well assumed parameters \\(\\mu\\) (mu) \\(\\sigma\\) (sigma). parameters control various details integration problem.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator.html","id":"other-parameters","dir":"Reference","previous_headings":"","what":"Other parameters","title":"Evaluate performance characteristics of an estimator — evaluate_estimator","text":"two-armed data_distribution, use_full_twoarm_sampling_distribution TRUE, sample means groups integrated independently. use_full_twoarm_sampling_distribution FALSE, difference sample means integrated. true_parameter controls parameters supposed estimated. usually mu, set sigma one interested estimating standard deviation. parameter exact set FALSE (default), continuous version second-stage sample-size function n2 used. Otherwise, integer valued version function used, though considerably slower. parameters early_futility_part, continuation_part early_efficacy_part control parts sample-space integrated (default TRUE). can used conjunction parameter conditional_integral, enables calculation expected value performance score conditional reaching selected integration regions. Lastly, paramters tol, maxEval, absError control integration accuracy. handed hcubature function.","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate performance characteristics of an estimator — evaluate_estimator","text":"","code":"evaluate_estimator(   score = MSE(),   estimator = SampleMean(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu = c(0, 0.3, 0.6),   sigma = 1,   exact = FALSE ) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Estimator:                                                           Sample mean #> Assumed sigma:                                                                 1 #> Assumed mu:                                                          0.0 0.3 0.6 #> Results: #>  Expectation:                                -0.02491922  0.30567290  0.62041636 #>  Bias:                                    -0.024919220  0.005672903  0.020416356 #>  Variance:                                      0.02779122 0.03777824 0.02790974 #>  MSE:                                           0.02841219 0.03781042 0.02832657 #>   evaluate_estimator(   score = Coverage(),   estimator = StagewiseCombinationFunctionOrderingCI(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu = c(0, 0.3),   sigma = 1,   exact = FALSE ) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Estimator:                                                      SWCF ordering CI #> Assumed sigma:                                                                 1 #> Assumed mu:                                                              0.0 0.3 #> Results: #>  Coverage:                                                   0.9500681 0.9499744 #>"},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_scenarios_parallel.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate different scenarios in parallel — evaluate_scenarios_parallel","title":"Evaluate different scenarios in parallel — evaluate_scenarios_parallel","text":"function takes list lists scores, list lists estimators, lists lists various design parameters. possible combination elements respective sublists used create separate scenarios. scenarios evaluated independelty , allowing parallelization via future framework. scenario, one call evaluate_estimator function made.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_scenarios_parallel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate different scenarios in parallel — evaluate_scenarios_parallel","text":"","code":"evaluate_scenarios_parallel(   score_lists,   estimator_lists,   data_distribution_lists,   use_full_twoarm_sampling_distribution_lists,   design_lists,   true_parameter_lists,   mu_lists,   sigma_lists,   tol_lists,   maxEval_lists,   absError_lists,   exact_lists,   early_futility_part_lists,   continuation_part_lists,   early_efficacy_part_lists,   conditional_integral_lists )"},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_scenarios_parallel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate different scenarios in parallel — evaluate_scenarios_parallel","text":"score_lists list lists estimator scores. estimator_lists list lists estimators. data_distribution_lists list lists data distributions. use_full_twoarm_sampling_distribution_lists list lists use_full_twoarm_sampling_distribution_lists parameters. design_lists list lists designs. true_parameter_lists list lists true parameters. mu_lists list lists mu vectors. sigma_lists list lists sigma values. tol_lists list lists relative tolerances. maxEval_lists list lists maxEval boundaries. absError_lists list lists absError boundaries. exact_lists list lists `exact` parameters. early_futility_part_lists list lists `early_futility_part_lists` parameters. continuation_part_lists list lists `continuation_part_lists` parameters. early_efficacy_part_lists list lists `early_efficacy_part_lists` parameters. conditional_integral_lists list lists `conditional_integral_lists` parameters.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_scenarios_parallel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate different scenarios in parallel — evaluate_scenarios_parallel","text":"list data.frames containing results respective scenarios.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_scenarios_parallel.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluate different scenarios in parallel — evaluate_scenarios_parallel","text":"Concretely, cross product first sublist scores first sublist estimators parameters calculated. cross product second sublist scores, estimators design parameters calculated. cross products together make set scenarios. combinations say first sublist scores second sublist estimators considered.","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_scenarios_parallel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate different scenarios in parallel — evaluate_scenarios_parallel","text":"","code":"res <-evaluate_scenarios_parallel(  score_lists = list(c(MSE(), OverestimationProbability())),  estimator_lists =  list(c(SampleMean(), FirstStageSampleMean())),  data_distribution_lists = list(c(Normal(FALSE), Normal(TRUE))),  design_lists =  list(c(get_example_design())),  mu_lists = list(c(-1, 0, 1)),  sigma_lists = list(1) )"},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_design.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate an exemplary adaptive design — get_example_design","title":"Generate an exemplary adaptive design — get_example_design","text":"design optimized minimize expected sample size alternative hypothesis one-armed trial. boundaries chosen control type error 0.025 normally distributed test statistic (.e. known variance). alternative hypothesis mu=0.4, overall power 80%.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate an exemplary adaptive design — get_example_design","text":"","code":"get_example_design(two_armed = FALSE, label = NULL)"},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate an exemplary adaptive design — get_example_design","text":"two_armed (logical) determins whether design one- two-armed trials. label (optional) label assigned design.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_design.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate an exemplary adaptive design — get_example_design","text":"exemplary design class TwoStageDesign. object contains information sample size recalculation rule n2, futility efficacy boundaries c1f c1e second-stage rejection boundary c2.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_design.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate an exemplary adaptive design — get_example_design","text":"","code":"get_example_design() #> TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40>"},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_statistics.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a list of estimators and p-values to use in examples — get_example_statistics","title":"Generate a list of estimators and p-values to use in examples — get_example_statistics","text":"function generates list objects class PointEstimator, IntervalEstimators, PValues use examples analyze function.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_statistics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a list of estimators and p-values to use in examples — get_example_statistics","text":"","code":"get_example_statistics(   point_estimators = TRUE,   interval_estimators = TRUE,   p_values = TRUE )"},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_statistics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a list of estimators and p-values to use in examples — get_example_statistics","text":"point_estimators logical indicating whether point estimators included output list interval_estimators logical indicating whether interval estimators included output list p_values logical indicating whether p-values included output list","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_statistics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a list of estimators and p-values to use in examples — get_example_statistics","text":"list PointEstimators, IntervalEstimators PValue.","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_statistics.html","id":"point-estimators","dir":"Reference","previous_headings":"","what":"Point estimators","title":"Generate a list of estimators and p-values to use in examples — get_example_statistics","text":"following PointEstimators included: SampleMean PseudoRaoBlackwell MedianUnbiasedLikelihoodRatioOrdering BiasReduced","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_statistics.html","id":"confidence-intervals","dir":"Reference","previous_headings":"","what":"Confidence intervals","title":"Generate a list of estimators and p-values to use in examples — get_example_statistics","text":"following IntervalEstimators included: StagewiseCombinationFunctionOrderingCI LikelihoodRatioOrderingCI","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_statistics.html","id":"p-values","dir":"Reference","previous_headings":"","what":"P-Values","title":"Generate a list of estimators and p-values to use in examples — get_example_statistics","text":"following PValues included: StagewiseCombinationFunctionOrderingPValue LikelihoodRatioOrderingPValue","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_statistics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a list of estimators and p-values to use in examples — get_example_statistics","text":"","code":"set.seed(123) dat <- data.frame(   endpoint = c(rnorm(28, 0.3)),   stage = rep(1, 28) ) analyze(data = dat,         statistics = list(),         data_distribution = Normal(FALSE),         design = get_example_design(),         sigma = 1) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Observed number of stages:                                                     1 #> Observed n1 (total)                                                           28 #> Z1                                                                           1.3 #> Interim decision:                                       continue to second stage #> Calculated n2(Z1) (per group)                                           32.21129 #> Calculated c2(Z1)                                                           1.71 #>   # The results suggest recruiting 32 patients for the second stage dat <- rbind(   dat,   data.frame(     endpoint = rnorm(32, mean = 0.3),     stage = rep(2, 32))) analyze(data = dat,         statistics = get_example_statistics(),         data_distribution = Normal(FALSE),         design = get_example_design(),         sigma = 1) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Observed number of stages:                                                     2 #> Observed n1 (total)                                                           28 #> Z1                                                                           1.3 #> Interim decision:                                       continue to second stage #> Calculated n2(Z1) (per group)                                           32.21129 #> Calculated c2(Z1)                                                           1.71 #> Observed n2 (in total)                                                        32 #> Z2                                                                          2.66 #> Final test decision:                                                 reject null #>  #> Stage 2 results: #>  Sample mean:                                                          0.3656173 #>  Pseudo Rao-Blackwellized:                                             0.3135628 #>  Median unbiased (LR test ordering):                                   0.3420742 #>  Bias reduced MLE (iterations=1):                                       0.357214 #>  SWCF ordering CI:                                       [0.04664821, 0.6142449] #>  LR test ordering CI:                                    [0.08992822, 0.6106096] #>  SWCF ordering p-value:                                               0.01321363 #>  LR test ordering p-value:                                           0.003551316 #>"},{"path":"https://jan-imbi.github.io/adestr/reference/get_stagewise_estimators.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional representations of an estimator or p-value — get_stagewise_estimators","title":"Conditional representations of an estimator or p-value — get_stagewise_estimators","text":"generic determines functional representations point interval estimators p-values. functions returned two parts, one part calculate values conditional early futility efficacy stops (.e. second stage mean sample size available), one conditional continuation second stage.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_stagewise_estimators.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditional representations of an estimator or p-value — get_stagewise_estimators","text":"","code":"get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for VirtualPointEstimator,ANY get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for VirtualPValue,ANY get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for VirtualIntervalEstimator,ANY get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for PointEstimator,Student get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for PValue,Student get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for IntervalEstimator,Student get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for VirtualPointEstimator,Student get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for VirtualIntervalEstimator,Student get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for VirtualPValue,Student get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for PointEstimator,DataDistribution get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for PValue,DataDistribution get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for IntervalEstimator,DataDistribution get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for AdaptivelyWeightedSampleMean,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MinimizePeakVariance,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for BiasReduced,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for RaoBlackwell,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for PseudoRaoBlackwell,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for RepeatedCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for LinearShiftRepeatedPValue,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MLEOrderingPValue,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for LikelihoodRatioOrderingPValue,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for ScoreTestOrderingPValue,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for StagewiseCombinationFunctionOrderingPValue,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for NeymanPearsonOrderingPValue,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for NaivePValue,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for StagewiseCombinationFunctionOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MLEOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for LikelihoodRatioOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for ScoreTestOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for NeymanPearsonOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for NaiveCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MidpointStagewiseCombinationFunctionOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MidpointMLEOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MidpointLikelihoodRatioOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MidpointScoreTestOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MidpointNeymanPearsonOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MedianUnbiasedStagewiseCombinationFunctionOrdering,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MedianUnbiasedMLEOrdering,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MedianUnbiasedLikelihoodRatioOrdering,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MedianUnbiasedScoreTestOrdering,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MedianUnbiasedNeymanPearsonOrdering,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )"},{"path":"https://jan-imbi.github.io/adestr/reference/get_stagewise_estimators.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conditional representations of an estimator or p-value — get_stagewise_estimators","text":"estimator object class PointEstimator, IntervalEstimator PValue. data_distribution object class Normal Student. use_full_twoarm_sampling_distribution logical indicating whether estimator intended used full sampling distribution two-armed trial. design object class TwoStageDesign. sigma assumed standard deviation. exact logical indicating usage exact n2 function.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_stagewise_estimators.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conditional representations of an estimator or p-value — get_stagewise_estimators","text":"list conditional functional representations (one stage trial might end) estimator p-value.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_stagewise_estimators.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditional representations of an estimator or p-value — get_stagewise_estimators","text":"","code":"get_stagewise_estimators(   estimator = SampleMean(),   data_distribution = Normal(FALSE),   use_full_twoarm_sampling_distribution = FALSE,   design = get_example_design(),   sigma = 1,   exact = FALSE ) #> $g1 #> function (smean1, ...)  #> smean1 #> <bytecode: 0x559412701020> #> <environment: 0x55940f1846a8> #>  #> $g2 #> function (smean1, smean2, n1, n2, ...)  #> (n1 * smean1 + n2 * smean2)/(n1 + n2) #> <bytecode: 0x559412700cd8> #> <environment: 0x55940f1846a8> #>"},{"path":"https://jan-imbi.github.io/adestr/reference/get_statistics_from_paper.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate the list of estimators and p-values that were used in the paper — get_statistics_from_paper","title":"Generate the list of estimators and p-values that were used in the paper — get_statistics_from_paper","text":"Generate list estimators p-values used paper","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_statistics_from_paper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate the list of estimators and p-values that were used in the paper — get_statistics_from_paper","text":"","code":"get_statistics_from_paper(   point_estimators = TRUE,   interval_estimators = TRUE,   p_values = TRUE )"},{"path":"https://jan-imbi.github.io/adestr/reference/get_statistics_from_paper.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate the list of estimators and p-values that were used in the paper — get_statistics_from_paper","text":"point_estimators logical indicating whether point estimators included output list interval_estimators logical indicating whether interval estimators included output list p_values logical indicating whether p-values included output list","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_statistics_from_paper.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate the list of estimators and p-values that were used in the paper — get_statistics_from_paper","text":"list PointEstimators, IntervalEstimators PValue.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_statistics_from_paper.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate the list of estimators and p-values that were used in the paper — get_statistics_from_paper","text":"","code":"set.seed(123) dat <- data.frame(   endpoint = c(rnorm(28, 0.3)),   stage = rep(1, 28) ) analyze(data = dat,         statistics = list(),         data_distribution = Normal(FALSE),         design = get_example_design(),         sigma = 1) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Observed number of stages:                                                     1 #> Observed n1 (total)                                                           28 #> Z1                                                                           1.3 #> Interim decision:                                       continue to second stage #> Calculated n2(Z1) (per group)                                           32.21129 #> Calculated c2(Z1)                                                           1.71 #>   # The results suggest recruiting 32 patients for the second stage dat <- rbind(   dat,   data.frame(     endpoint = rnorm(32, mean = 0.3),     stage = rep(2, 32))) analyze(data = dat,         statistics = get_example_statistics(),         data_distribution = Normal(FALSE),         design = get_example_design(),         sigma = 1) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Observed number of stages:                                                     2 #> Observed n1 (total)                                                           28 #> Z1                                                                           1.3 #> Interim decision:                                       continue to second stage #> Calculated n2(Z1) (per group)                                           32.21129 #> Calculated c2(Z1)                                                           1.71 #> Observed n2 (in total)                                                        32 #> Z2                                                                          2.66 #> Final test decision:                                                 reject null #>  #> Stage 2 results: #>  Sample mean:                                                          0.3656173 #>  Pseudo Rao-Blackwellized:                                             0.3135628 #>  Median unbiased (LR test ordering):                                   0.3420742 #>  Bias reduced MLE (iterations=1):                                       0.357214 #>  SWCF ordering CI:                                       [0.04664821, 0.6142449] #>  LR test ordering CI:                                    [0.08992822, 0.6106096] #>  SWCF ordering p-value:                                               0.01321363 #>  LR test ordering p-value:                                           0.003551316 #>"},{"path":"https://jan-imbi.github.io/adestr/reference/n2_extrapol.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the second-stage sample size for a design with cached spline parameters — n2_extrapol","title":"Calculate the second-stage sample size for a design with cached spline parameters — n2_extrapol","text":"Also extrapolates results values outside [c1f, c1e].","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/n2_extrapol.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the second-stage sample size for a design with cached spline parameters — n2_extrapol","text":"","code":"n2_extrapol(design, x1)"},{"path":"https://jan-imbi.github.io/adestr/reference/n2_extrapol.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the second-stage sample size for a design with cached spline parameters — n2_extrapol","text":"design object class TwoStageDesignWithCache. x1 first-stage test statistic","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResult-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResult-method","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResult-method","text":"function extract values mu score values facet plot one facet per score. input argument list, different estimators displayed facets, differentiated color.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResult-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResult-method","text":"","code":"# S4 method for EstimatorScoreResult plot(x, y, ...)"},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResult-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResult-method","text":"x output object evaluate_estimator (EstimatorScoreResult) list objects (EstimatorScoreResultList). y unused. ... additional arguments handed ggplot.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResult-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResult-method","text":"ggplot2 object visualizing score values.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResult-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResult-method","text":"","code":"score_result1 <- evaluate_estimator(   MSE(),   estimator = SampleMean(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu=seq(-.75, 1.32, 0.03),   sigma=1) # Plotting the result of evaluate_estimator plot(score_result1)   score_result2 <- evaluate_estimator(   MSE(),   estimator = AdaptivelyWeightedSampleMean(w1 = 0.8),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu=seq(-.75, 1.32, 0.03),   sigma=1) # Plotting a list of different score results plot(c(score_result1, score_result2))"},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResultList-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResultList-method","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResultList-method","text":"function extract values mu score values facet plot one facet per score. input argument list, different estimators displayed facets, differentiated color.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResultList-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResultList-method","text":"","code":"# S4 method for EstimatorScoreResultList plot(x, y, ...)"},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResultList-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResultList-method","text":"x output object evaluate_estimator (EstimatorScoreResult) list objects (EstimatorScoreResultList). y unused. ... additional arguments handed ggplot.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResultList-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResultList-method","text":"ggplot2 object visualizing score values.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResultList-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResultList-method","text":"","code":"score_result1 <- evaluate_estimator(   MSE(),   estimator = SampleMean(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu=seq(-.75, 1.32, 0.03),   sigma=1) # Plotting the result of evaluate_estimator plot(score_result1)   score_result2 <- evaluate_estimator(   MSE(),   estimator = AdaptivelyWeightedSampleMean(w1 = 0.8),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu=seq(-.75, 1.32, 0.03),   sigma=1) # Plotting a list of different score results plot(c(score_result1, score_result2))"},{"path":"https://jan-imbi.github.io/adestr/reference/plot-list-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot performance scores for point and interval estimators — plot,list-method","title":"Plot performance scores for point and interval estimators — plot,list-method","text":"function extract values mu score values facet plot one facet per score. input argument list, different estimators displayed facets, differentiated color.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-list-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot performance scores for point and interval estimators — plot,list-method","text":"","code":"# S4 method for list plot(x, y, ...)"},{"path":"https://jan-imbi.github.io/adestr/reference/plot-list-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot performance scores for point and interval estimators — plot,list-method","text":"x output object evaluate_estimator (EstimatorScoreResult) list objects (EstimatorScoreResultList). y unused. ... additional arguments handed ggplot.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-list-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot performance scores for point and interval estimators — plot,list-method","text":"ggplot2 object visualizing score values.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-list-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot performance scores for point and interval estimators — plot,list-method","text":"","code":"score_result1 <- evaluate_estimator(   MSE(),   estimator = SampleMean(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu=seq(-.75, 1.32, 0.03),   sigma=1) # Plotting the result of evaluate_estimator plot(score_result1)   score_result2 <- evaluate_estimator(   MSE(),   estimator = AdaptivelyWeightedSampleMean(w1 = 0.8),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu=seq(-.75, 1.32, 0.03),   sigma=1) # Plotting a list of different score results plot(c(score_result1, score_result2))"},{"path":"https://jan-imbi.github.io/adestr/reference/plot_p.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot p-values and implied rejection boundaries — plot_p","title":"Plot p-values and implied rejection boundaries — plot_p","text":"Creates plot p-values implied rejection boundaries grid values first second-stage test statistics.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot_p.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot p-values and implied rejection boundaries — plot_p","text":"","code":"plot_p(   estimator,   data_distribution,   design,   mu = 0,   sigma,   boundary_color = \"lightgreen\",   subdivisions = 100,   ... )"},{"path":"https://jan-imbi.github.io/adestr/reference/plot_p.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot p-values and implied rejection boundaries — plot_p","text":"estimator object class PointEstimator, IntervalEstimator PValue. data_distribution object class Normal Student. design object class TwoStageDesign. mu expected value underlying normal distribution. sigma assumed standard deviation. boundary_color color implied rejection boundary. subdivisions number subdivisions per axis grid test statistic values. ... additional arguments handed ggplot","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot_p.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot p-values and implied rejection boundaries — plot_p","text":"ggplot2 object visualizing p-values grid possible test-statistic values.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot_p.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot p-values and implied rejection boundaries — plot_p","text":"first-stage test statistic lies futility threshold (c1f) early efficacy threshold (c1e) TwoStageDesign, second-stage test statistics. p-values regions based first-stage values. first-stage test statistic values c1f c1e, first second-stage test statistic determine p-value. rejection boundary signals line ","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot_p.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot p-values and implied rejection boundaries — plot_p","text":"","code":"plot_p(estimator = StagewiseCombinationFunctionOrderingPValue(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu = 0,   sigma = 1)"},{"path":"https://jan-imbi.github.io/adestr/news/index.html","id":"adestr-051","dir":"Changelog","previous_headings":"","what":"adestr 0.5.1","title":"adestr 0.5.1","text":"Replaced raster graphics vignettes vector graphics.","code":""},{"path":"https://jan-imbi.github.io/adestr/news/index.html","id":"adestr-050","dir":"Changelog","previous_headings":"","what":"adestr 0.5.0","title":"adestr 0.5.0","text":"CRAN release: 2023-09-27 First CRAN submission.","code":""},{"path":"https://jan-imbi.github.io/adestr/news/index.html","id":"adestr-001","dir":"Changelog","previous_headings":"","what":"adestr 0.0.1","title":"adestr 0.0.1","text":"Added NEWS.md file track changes package.","code":""}]
