[{"path":"https://jan-imbi.github.io/adestr/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 2, June 1991Copyright © 1989, 1991 Free Software Foundation, Inc.,51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://jan-imbi.github.io/adestr/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"licenses software designed take away freedom share change . contrast, GNU General Public License intended guarantee freedom share change free software–make sure software free users. General Public License applies Free Software Foundation’s software program whose authors commit using . (Free Software Foundation software covered GNU Lesser General Public License instead.) can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge service wish), receive source code can get want , can change software use pieces new free programs; know can things. protect rights, need make restrictions forbid anyone deny rights ask surrender rights. restrictions translate certain responsibilities distribute copies software, modify . example, distribute copies program, whether gratis fee, must give recipients rights . must make sure , , receive can get source code. must show terms know rights. protect rights two steps: (1) copyright software, (2) offer license gives legal permission copy, distribute /modify software. Also, author’s protection , want make certain everyone understands warranty free software. software modified someone else passed , want recipients know original, problems introduced others reflect original authors’ reputations. Finally, free program threatened constantly software patents. wish avoid danger redistributors free program individually obtain patent licenses, effect making program proprietary. prevent , made clear patent must licensed everyone’s free use licensed . precise terms conditions copying, distribution modification follow.","code":""},{"path":"https://jan-imbi.github.io/adestr/LICENSE.html","id":"terms-and-conditions-for-copying-distribution-and-modification","dir":"","previous_headings":"","what":"TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION","title":"GNU General Public License","text":"0. License applies program work contains notice placed copyright holder saying may distributed terms General Public License. “Program”, , refers program work, “work based Program” means either Program derivative work copyright law: say, work containing Program portion , either verbatim modifications /translated another language. (Hereinafter, translation included without limitation term “modification”.) licensee addressed “”. Activities copying, distribution modification covered License; outside scope. act running Program restricted, output Program covered contents constitute work based Program (independent made running Program). Whether true depends Program . 1. may copy distribute verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice disclaimer warranty; keep intact notices refer License absence warranty; give recipients Program copy License along Program. may charge fee physical act transferring copy, may option offer warranty protection exchange fee. 2. may modify copy copies Program portion , thus forming work based Program, copy distribute modifications work terms Section 1 , provided also meet conditions: ) must cause modified files carry prominent notices stating changed files date change. b) must cause work distribute publish, whole part contains derived Program part thereof, licensed whole charge third parties terms License. c) modified program normally reads commands interactively run, must cause , started running interactive use ordinary way, print display announcement including appropriate copyright notice notice warranty (else, saying provide warranty) users may redistribute program conditions, telling user view copy License. (Exception: Program interactive normally print announcement, work based Program required print announcement.) requirements apply modified work whole. identifiable sections work derived Program, can reasonably considered independent separate works , License, terms, apply sections distribute separate works. distribute sections part whole work based Program, distribution whole must terms License, whose permissions licensees extend entire whole, thus every part regardless wrote . Thus, intent section claim rights contest rights work written entirely ; rather, intent exercise right control distribution derivative collective works based Program. addition, mere aggregation another work based Program Program (work based Program) volume storage distribution medium bring work scope License. 3. may copy distribute Program (work based , Section 2) object code executable form terms Sections 1 2 provided also one following: ) Accompany complete corresponding machine-readable source code, must distributed terms Sections 1 2 medium customarily used software interchange; , b) Accompany written offer, valid least three years, give third party, charge cost physically performing source distribution, complete machine-readable copy corresponding source code, distributed terms Sections 1 2 medium customarily used software interchange; , c) Accompany information received offer distribute corresponding source code. (alternative allowed noncommercial distribution received program object code executable form offer, accord Subsection b .) source code work means preferred form work making modifications . executable work, complete source code means source code modules contains, plus associated interface definition files, plus scripts used control compilation installation executable. However, special exception, source code distributed need include anything normally distributed (either source binary form) major components (compiler, kernel, ) operating system executable runs, unless component accompanies executable. distribution executable object code made offering access copy designated place, offering equivalent access copy source code place counts distribution source code, even though third parties compelled copy source along object code. 4. may copy, modify, sublicense, distribute Program except expressly provided License. attempt otherwise copy, modify, sublicense distribute Program void, automatically terminate rights License. However, parties received copies, rights, License licenses terminated long parties remain full compliance. 5. required accept License, since signed . However, nothing else grants permission modify distribute Program derivative works. actions prohibited law accept License. Therefore, modifying distributing Program (work based Program), indicate acceptance License , terms conditions copying, distributing modifying Program works based . 6. time redistribute Program (work based Program), recipient automatically receives license original licensor copy, distribute modify Program subject terms conditions. may impose restrictions recipients’ exercise rights granted herein. responsible enforcing compliance third parties License. 7. , consequence court judgment allegation patent infringement reason (limited patent issues), conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. distribute satisfy simultaneously obligations License pertinent obligations, consequence may distribute Program . example, patent license permit royalty-free redistribution Program receive copies directly indirectly , way satisfy License refrain entirely distribution Program. portion section held invalid unenforceable particular circumstance, balance section intended apply section whole intended apply circumstances. purpose section induce infringe patents property right claims contest validity claims; section sole purpose protecting integrity free software distribution system, implemented public license practices. Many people made generous contributions wide range software distributed system reliance consistent application system; author/donor decide willing distribute software system licensee impose choice. section intended make thoroughly clear believed consequence rest License. 8. distribution /use Program restricted certain countries either patents copyrighted interfaces, original copyright holder places Program License may add explicit geographical distribution limitation excluding countries, distribution permitted among countries thus excluded. case, License incorporates limitation written body License. 9. Free Software Foundation may publish revised /new versions General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies version number License applies “later version”, option following terms conditions either version later version published Free Software Foundation. Program specify version number License, may choose version ever published Free Software Foundation. 10. wish incorporate parts Program free programs whose distribution conditions different, write author ask permission. software copyrighted Free Software Foundation, write Free Software Foundation; sometimes make exceptions . decision guided two goals preserving free status derivatives free software promoting sharing reuse software generally.","code":""},{"path":"https://jan-imbi.github.io/adestr/LICENSE.html","id":"no-warranty","dir":"","previous_headings":"","what":"NO WARRANTY","title":"GNU General Public License","text":"11. PROGRAM LICENSED FREE CHARGE, WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION. 12. EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MAY MODIFY /REDISTRIBUTE PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES. END TERMS CONDITIONS","code":""},{"path":"https://jan-imbi.github.io/adestr/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively convey exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program interactive, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, commands use may called something show w show c; even mouse-clicks menu items–whatever suits program. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. sample; alter names: General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. Gnomovision version 69, Copyright (C) year name of author Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'. This is free software, and you are welcome to redistribute it under certain conditions; type `show c' for details. Yoyodyne, Inc., hereby disclaims all copyright interest in the program `Gnomovision' (which makes passes at compilers) written by James Hacker.  <signature of Ty Coon>, 1 April 1989 Ty Coon, President of Vice"},{"path":"https://jan-imbi.github.io/adestr/articles/Introduction.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Introduction to adestr","text":"package implements methods evaluate performance characteristics various point interval estimators adaptive two-stage designs prespecified sample-size recalculation rules. , allows evaluation estimators real datasets, implements methods calculate p-values. Currently, works designs objects produced R-package adoptr, calculates optimal design parameters adaptive two-stage designs. can learn adoptr : optad.github.io/adoptr/. introductory vignette covering common usecases given https://jan-imbi.github.io/adestr/articles/Introduction.html. package comes suite unit tests. code test cases can viewed : https://github.com/jan-imbi/adestr/tree/master/tests/testthat. authors assume responsibility correctness code results produced usage. Use risk. may also interested reference implementation looking https://github.com/jan-imbi/adestr/blob/master/R/reference_implementation.R. uses notation paper (doi.org/10.1002/sim.10020) may therefore easier understand first.","code":""},{"path":"https://jan-imbi.github.io/adestr/articles/Introduction.html","id":"fitting-a-design-with-adoptr","dir":"Articles","previous_headings":"","what":"Fitting a design with adoptr","title":"Introduction to adestr","text":"order showcase capabilities package, need trial design first. refer example adoptr documentation . can read optimal adaptive designs fitted via adoptr package : optad.github.io/adoptr/articles/adoptr_jss.html. sake introduction, pre-computed version first example optad.github.io/adoptr/articles/adoptr.html provided package via get_example_design function.","code":"library(adestr) #> Loading required package: adoptr get_example_design(two_armed = TRUE) #> TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80>"},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/articles/Introduction.html","id":"evaluating-the-mean-squared-of-the-sample-mean-and-the-weighted-sample-mean","dir":"Articles","previous_headings":"Evaluating point estimators","what":"Evaluating the mean squared of the sample mean and the weighted sample mean","title":"Introduction to adestr","text":"Now created optimal adaptive design, can investigate performance characteristics various estimators mean design. end, evaluate_estimator function can used. mean squared error sample mean depends true underlying value paramter μ\\mu, course unknown. Therefore, may advisable use evaluate_estimator function array values μ\\mu investigate distributional properties estimator. following, MSE sample mean vs. weighted sample mean fixed weights plotted.","code":"evaluate_estimator(  score = MSE(),  estimator = SampleMean(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = 0.3,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                                           Sample mean #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.3 #> Results: #>  Expectation:                                                          0.3056727 #>  Bias:                                                               0.005672677 #>  Variance:                                                            0.03777784 #>  MSE:                                                                 0.03781002 mse_mle <- evaluate_estimator(   score = MSE(),   estimator = SampleMean(),   data_distribution = Normal(two_armed = TRUE),   design = get_example_design(two_armed = TRUE),   mu = seq(-0.75, 1.32, .03),   sigma = 1 ) mse_weighted_sample_means <- evaluate_estimator(   score = MSE(),   estimator = WeightedSampleMean(w1 = .8),   data_distribution = Normal(two_armed = TRUE),   design = get_example_design(two_armed = TRUE),   mu = seq(-0.75, 1.32, .03),   sigma = 1 ) plot(c(mse_mle, mse_weighted_sample_means))"},{"path":"https://jan-imbi.github.io/adestr/articles/Introduction.html","id":"evaluating-median-unbiased-estimators","dir":"Articles","previous_headings":"Evaluating point estimators","what":"Evaluating median unbiased estimators","title":"Introduction to adestr","text":"Median unbiased estimators estimators probability overestimation equal probability underestimation. can derived choosing sample space ordering. adestr, 5 different sample-space orderings implemented: MLE (maximum likelihood estimator) ordering, LR (likelihood ratio) test ordering, ST (score test) ordering, SWCF (stage-wise combination function) ordering, NP (Neyman-Pearson) ordering. latter (NP ordering) useful calculation p-values, estimators derived ordering usually nonsense. Lets look ‘median-unbiased’ property estimators derived four orderings: Compare Overestimation probability sample mean:","code":"evaluate_estimator(  score = OverestimationProbability(),  estimator = MedianUnbiasedMLEOrdering(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = 0.4,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                        Median unbiased (MLE ordering) #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.4 #> Results: #>  Probability of overestimation:                                        0.4988042  evaluate_estimator(  score = OverestimationProbability(),  estimator = MedianUnbiasedLikelihoodRatioOrdering(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = 0.4,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                    Median unbiased (LR test ordering) #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.4 #> Results: #>  Probability of overestimation:                                        0.4990921  evaluate_estimator(  score = OverestimationProbability(),  estimator = MedianUnbiasedScoreTestOrdering(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = 0.4,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                 Median unbiased (Score test ordering) #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.4 #> Results: #>  Probability of overestimation:                                        0.5037828  evaluate_estimator(  score = OverestimationProbability(),  estimator = MedianUnbiasedStagewiseCombinationFunctionOrdering(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = 0.4,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                       Median unbiased (SWCF ordering) #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.4 #> Results: #>  Probability of overestimation:                                        0.4976513 evaluate_estimator(  score = OverestimationProbability(),  estimator = SampleMean(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = 0.4,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                                           Sample mean #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.4 #> Results: #>  Probability of overestimation:                                        0.5943933"},{"path":"https://jan-imbi.github.io/adestr/articles/Introduction.html","id":"evaluating-bias-reduced-unbiased-estimators","dir":"Articles","previous_headings":"Evaluating point estimators","what":"Evaluating bias-reduced unbiased estimators","title":"Introduction to adestr","text":"Apart sample-space ordering based methods, various ways defining alternative point estimators may desirable properties. couple presented paper evaluated mu=0.3 sigma=1.","code":"evaluate_estimator(  score = MSE(),  estimator = SampleMean(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = 0.3,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                                           Sample mean #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.3 #> Results: #>  Expectation:                                                          0.3056727 #>  Bias:                                                               0.005672677 #>  Variance:                                                            0.03777784 #>  MSE:                                                                 0.03781002 evaluate_estimator(  score = MSE(),  estimator = BiasReduced(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = 0.3,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                       Bias reduced MLE (iterations=1) #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.3 #> Results: #>  Expectation:                                                          0.3042277 #>  Bias:                                                               0.004227723 #>  Variance:                                                            0.03453116 #>  MSE:                                                                 0.03454903 evaluate_estimator(  score = MSE(),  estimator = PseudoRaoBlackwell(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = 0.3,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                              Pseudo Rao-Blackwellized #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.3 #> Results: #>  Expectation:                                                          0.3022287 #>  Bias:                                                               0.002228688 #>  Variance:                                                            0.03268444 #>  MSE:                                                                 0.03268941 evaluate_estimator(  score = MSE(),  estimator = RaoBlackwell(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = 0.3,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                                     Rao-Blackwellized #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.3 #> Results: #>  Expectation:                                                           0.300153 #>  Bias:                                                              0.0001530249 #>  Variance:                                                            0.03548938 #>  MSE:                                                                 0.03548941 evaluate_estimator(  score = MSE(),  estimator = AdaptivelyWeightedSampleMean(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = 0.3,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                AdaptivelyWeightedSampleMean(w1^2=50%) #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.3 #> Results: #>  Expectation:                                                          0.3039742 #>  Bias:                                                               0.003974222 #>  Variance:                                                            0.03817511 #>  MSE:                                                                  0.0381909"},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/articles/Introduction.html","id":"evaluating-coverage","dir":"Articles","previous_headings":"Evaluating interval estimators","what":"Evaluating coverage","title":"Introduction to adestr","text":"coverage interval estimator probability estimator cover true value parameter question. may evaluated like : can see, naive confidence interval correct coverage 95%. example estimator achieves correct coverage: parameter mu chose example, naive confidence interval performs particularly bad. can plot coverage naive confidence interval array values like :","code":"evaluate_estimator(  score = Coverage(),  estimator = NaiveCI(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = .07,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                                              Naive CI #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                 0.07 #> Results: #>  Coverage:                                                              0.933259 evaluate_estimator(  score = Coverage(),  estimator = LikelihoodRatioOrderingCI(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = .07,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                                   LR test ordering CI #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                 0.07 #> Results: #>  Coverage:                                                             0.9500889 coverage_naive <- evaluate_estimator(  score = Coverage(),  estimator = NaiveCI(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = seq(-0.75, 1.32, .03),  sigma = 1 ) plot(coverage_naive)"},{"path":"https://jan-imbi.github.io/adestr/articles/Introduction.html","id":"evaluating-the-widht-of-an-interval-estimator","dir":"Articles","previous_headings":"Evaluating interval estimators","what":"Evaluating the widht of an interval estimator","title":"Introduction to adestr","text":"Amongst interval estimators correct coverage, one might interested selecting one least width. can evaluate expected width interval estimator particular set assumptions like :","code":"evaluate_estimator(  score = Width(),  estimator = MLEOrderingCI(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = .3,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                                       MLE ordering CI #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.3 #> Results: #>  Width:                                                                0.6453952 evaluate_estimator(  score = Width(),  estimator = LikelihoodRatioOrderingCI(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = .3,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                                   LR test ordering CI #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.3 #> Results: #>  Width:                                                                0.6351904 evaluate_estimator(  score = Width(),  estimator = ScoreTestOrderingCI(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = .3,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                                Score test ordering CI #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.3 #> Results: #>  Width:                                                                0.6502033 evaluate_estimator(  score = Width(),  estimator = StagewiseCombinationFunctionOrderingCI(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = .3,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                                      SWCF ordering CI #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.3 #> Results: #>  Width:                                                                0.6575988"},{"path":"https://jan-imbi.github.io/adestr/articles/Introduction.html","id":"evaluating-the-centrality-of-a-point-estimator-with-respect-to-an-interval-estimator","dir":"Articles","previous_headings":"Evaluating interval estimators","what":"Evaluating the centrality of a point estimator with respect to an interval estimator","title":"Introduction to adestr","text":"choosing combination point interval estimator report end trial, one might want point estimator less middle respective interval. evaluate ‘centrality’ estimator, case defined difference distance point estimator lower end interval upper end interval, one can use following command:","code":"evaluate_estimator(  score = Centrality(interval = StagewiseCombinationFunctionOrderingCI()),  estimator = SampleMean(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = .3,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                                           Sample mean #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.3 #> Results: #>  Centrality with respect to SWCF ordering CI:                         0.00715509 evaluate_estimator(  score = Centrality(interval = NaiveCI()),  estimator = SampleMean(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = .3,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                                           Sample mean #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.3 #> Results: #>  Centrality with respect to Naive CI:                              -4.072497e-18"},{"path":"https://jan-imbi.github.io/adestr/articles/Introduction.html","id":"evaluating-agreement-with-the-primary-test-decision-of-the-design-for-an-interval-estimator","dir":"Articles","previous_headings":"Evaluating interval estimators","what":"Evaluating agreement with the primary test decision of the design for an interval estimator","title":"Introduction to adestr","text":"framework optimal adaptive designs, rejection boundaries primary testing decision design optimized directly derived common test statistic. Therefore, confidence intervals derived statistics necessarily agree primary test decision. One may evaluate chance agreement like : confidence interval derived stage-wise combination function ordering (construction) always agrees primary testing decision.","code":"evaluate_estimator(  score = TestAgreement(),  estimator = MLEOrderingCI(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = .3,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                                       MLE ordering CI #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.3 #> Results: #>  Agreement with test decision:                                         0.9867598 evaluate_estimator(  score = TestAgreement(),  estimator = LikelihoodRatioOrderingCI(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = .3,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                                   LR test ordering CI #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.3 #> Results: #>  Agreement with test decision:                                         0.9859001 evaluate_estimator(  score = TestAgreement(),  estimator = ScoreTestOrderingCI(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = .3,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                                Score test ordering CI #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.3 #> Results: #>  Agreement with test decision:                                         0.8269152 evaluate_estimator(  score = TestAgreement(),  estimator = StagewiseCombinationFunctionOrderingCI(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = .3,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                                      SWCF ordering CI #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.3 #> Results: #>  Agreement with test decision:                                          1.000034"},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/articles/Introduction.html","id":"evaluating-agreement-with-the-primary-test-decision-of-the-design-for-a-p-value","dir":"Articles","previous_headings":"Evaluating p-values","what":"Evaluating agreement with the primary test decision of the design for a p-value","title":"Introduction to adestr","text":"Like confidence intervals, p-values always come associated test decision. However, reason described chapter interval estimators, test decision derived various ways calculating p-values may necessarily agree primary test decision optimal adaptive design. One may evaluate probability agreement particular set assumptions like : , see p-value derived stage-wise combination function ordering always agrees primary testing decision.","code":"evaluate_estimator(  score = TestAgreement(),  estimator = MLEOrderingPValue(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = .3,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                                  MLE ordering p-value #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.3 #> Results: #>  Agreement with test decision:                                         0.9846693 evaluate_estimator(  score = TestAgreement(),  estimator = LikelihoodRatioOrderingPValue(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = .3,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                              LR test ordering p-value #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.3 #> Results: #>  Agreement with test decision:                                         0.9859001 evaluate_estimator(  score = TestAgreement(),  estimator = ScoreTestOrderingPValue(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = .3,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                           Score test ordering p-value #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.3 #> Results: #>  Agreement with test decision:                                         0.8269606 evaluate_estimator(  score = TestAgreement(),  estimator = StagewiseCombinationFunctionOrderingPValue(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = .3,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                                 SWCF ordering p-value #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.3 #> Results: #>  Agreement with test decision:                                          1.000034"},{"path":"https://jan-imbi.github.io/adestr/articles/Introduction.html","id":"conducting-larger-scale-investigations-in-the-performance-characteristics-of-end-of-trial-statistics","dir":"Articles","previous_headings":"","what":"Conducting larger scale investigations in the performance characteristics of end-of-trial statistics","title":"Introduction to adestr","text":"far looked evaluating performance characteristics particular set assumptions, choice performance characteristics choice estimators. However, designing trial, one might want produce results variety different scenarios, can time consuming. evaluation performance characteristics adestr can run parallel using future framework. get back list data.frames containing results scenario. Note within one scenario, evaluation take place cross-product arguments supplied! means within one scenario, every estimator evaluated every score every point mu every sigma every design. Depending settings, can get time-consuming fast, making parallelization essential.","code":"library(future.apply) #> Loading required package: future # Change to e.g. plan(multisession) for parallel computing plan(sequential)  # Scenario 1: scores1 <- list(MSE(), OverestimationProbability()) estimators1 <- list(SampleMean(), BiasReduced()) dist1 <- list(Normal(two_armed = TRUE)) designs1 <- list(get_example_design(two_armed = TRUE)) mu1 <- seq(-1,1,.5) sigma1 <- 1  # Scenario 2: scores2 <- list(Coverage(), Width()) estimators2 <- list(NaiveCI(), StagewiseCombinationFunctionOrderingCI()) dist2 <- list(Normal(two_armed = TRUE)) designs2 <- list(get_example_design(two_armed = TRUE)) mu2 <- seq(-1,1,.5) sigma2 <- 1  # Evaluate in parallel res <- evaluate_scenarios_parallel(   score_lists = list(scores1, scores2),   estimator_lists =  list(estimators1, estimators2),   data_distribution_lists = list(dist1, dist2),   design_lists =  list(designs1, designs2),   mu_lists = list(mu1, mu2),   sigma_lists = list(sigma1, sigma2) )  res[[1]] #>                          estimator data_distribution #> 1  Bias reduced MLE (iterations=1) Normal<two-armed> #> 2  Bias reduced MLE (iterations=1) Normal<two-armed> #> 3  Bias reduced MLE (iterations=1) Normal<two-armed> #> 4  Bias reduced MLE (iterations=1) Normal<two-armed> #> 5  Bias reduced MLE (iterations=1) Normal<two-armed> #> 6                      Sample mean Normal<two-armed> #> 7                      Sample mean Normal<two-armed> #> 8                      Sample mean Normal<two-armed> #> 9                      Sample mean Normal<two-armed> #> 10                     Sample mean Normal<two-armed> #>                                         design   mu sigma Expectation #> 1  TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> -0.5     1 -0.49939216 #> 2  TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> -1.0     1 -0.99999772 #> 3  TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80>  0.0     1 -0.01606505 #> 4  TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80>  0.5     1  0.51833127 #> 5  TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80>  1.0     1  0.99918705 #> 6  TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> -0.5     1 -0.50010511 #> 7  TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> -1.0     1 -0.99999807 #> 8  TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80>  0.0     1 -0.02491862 #> 9  TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80>  0.5     1  0.52702761 #> 10 TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80>  1.0     1  1.00028935 #>    error_Expectation functionEvaluations_Expectation          Bias   error_Bias #> 1       1.960169e-05                              96  6.078357e-04 1.960169e-05 #> 2       9.514441e-04                              62  2.284733e-06 9.514441e-04 #> 3       1.777337e-05                             213 -1.606505e-02 1.777337e-05 #> 4       4.691721e-04                             591  1.833127e-02 4.691721e-04 #> 5       1.116012e-05                             383 -8.129478e-04 1.116012e-05 #> 6       8.315412e-06                              96 -1.051082e-04 8.315412e-06 #> 7       9.514289e-04                              62  1.932112e-06 9.514289e-04 #> 8       1.594939e-05                             213 -2.491862e-02 1.594939e-05 #> 9       2.894096e-04                             523  2.702761e-02 2.894096e-04 #> 10      9.213421e-06                             383  2.893473e-04 9.213421e-06 #>    functionEvaluations_Bias   Variance error_Variance #> 1                        96 0.03584328   1.763680e-05 #> 2                        62 0.03550108   6.144227e-09 #> 3                       213 0.02797111   7.090928e-06 #> 4                       591 0.02881243   2.126220e-05 #> 5                       383 0.03583686   1.865170e-05 #> 6                        96 0.03539081   9.104316e-06 #> 7                        62 0.03549953   4.460077e-09 #> 8                       213 0.02779093   7.299455e-06 #> 9                       523 0.02945197   9.840547e-06 #> 10                      383 0.03520539   1.135277e-05 #>    functionEvaluations_Variance        MSE    error_MSE functionEvaluations_MSE #> 1                            96 0.03584365 3.723849e-05                     192 #> 2                           122 0.03550108 9.514503e-04                     184 #> 3                           247 0.02822920 2.486430e-05                     460 #> 4                           707 0.02914847 4.904343e-04                    1298 #> 5                           213 0.03583752 2.981182e-05                     596 #> 6                            96 0.03539082 1.741973e-05                     192 #> 7                           122 0.03549953 9.514333e-04                     184 #> 8                           247 0.02841187 2.324884e-05                     460 #> 9                           553 0.03018246 2.992501e-04                    1076 #> 10                          213 0.03520547 2.056619e-05                     596 #>    Probability of overestimation error_Probability of overestimation #> 1                      0.5001404                        2.251825e-04 #> 2                      0.5000217                        3.779495e-04 #> 3                      0.5055955                        1.861311e-03 #> 4                      0.5141305                        6.286754e-03 #> 5                      0.4997007                        3.746175e-04 #> 6                      0.4999989                        2.248484e-05 #> 7                      0.5000217                        3.779495e-04 #> 8                      0.4736938                        1.457061e-03 #> 9                      0.5550895                        1.395147e-02 #> 10                     0.4999743                        1.249999e-04 #>    functionEvaluations_Probability of overestimation #> 1                                                528 #> 2                                                362 #> 3                                               1393 #> 4                                               1333 #> 5                                                407 #> 6                                                528 #> 7                                                362 #> 8                                               1303 #> 9                                               1363 #> 10                                               377 #>                                                                                                                    EstimatorScoreResult #> 1  <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots>, <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots> #> 2  <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots>, <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots> #> 3  <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots>, <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots> #> 4  <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots>, <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots> #> 5  <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots>, <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots> #> 6  <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots>, <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots> #> 7  <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots>, <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots> #> 8  <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots>, <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots> #> 9  <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots>, <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots> #> 10 <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots>, <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots> res[[2]] #>           estimator data_distribution #> 1          Naive CI Normal<two-armed> #> 2          Naive CI Normal<two-armed> #> 3          Naive CI Normal<two-armed> #> 4          Naive CI Normal<two-armed> #> 5          Naive CI Normal<two-armed> #> 6  SWCF ordering CI Normal<two-armed> #> 7  SWCF ordering CI Normal<two-armed> #> 8  SWCF ordering CI Normal<two-armed> #> 9  SWCF ordering CI Normal<two-armed> #> 10 SWCF ordering CI Normal<two-armed> #>                                         design   mu sigma  Coverage #> 1  TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> -0.5     1 0.9500604 #> 2  TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> -1.0     1 0.9499647 #> 3  TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80>  0.0     1 0.9449795 #> 4  TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80>  0.5     1 0.9372047 #> 5  TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80>  1.0     1 0.9500391 #> 6  TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> -0.5     1 0.9499836 #> 7  TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> -1.0     1 0.9499647 #> 8  TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80>  0.0     1 0.9500699 #> 9  TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80>  0.5     1 0.9499538 #> 10 TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80>  1.0     1 0.9498600 #>    error_Coverage functionEvaluations_Coverage     Width  error_Width #> 1    0.0008288183                          712 0.7383716 9.444517e-06 #> 2    0.0008820986                          482 0.7384423 3.414488e-04 #> 3    0.0010153071                         1273 0.6918503 2.783059e-05 #> 4    0.0034991405                         1573 0.6778015 1.804778e-04 #> 5    0.0008299689                         1453 0.7382501 1.050093e-05 #> 6    0.0008194698                          542 0.7384927 8.305015e-06 #> 7    0.0008820986                          482 0.7384423 3.414488e-04 #> 8    0.0021817246                         1273 0.7163671 1.228666e-04 #> 9    0.0006645727                         1063 0.6996062 1.999098e-04 #> 10   0.0008090573                          467 0.7384132 1.013179e-05 #>    functionEvaluations_Width #> 1                        164 #> 2                         62 #> 3                        179 #> 4                        421 #> 5                        383 #> 6                         62 #> 7                         62 #> 8                        281 #> 9                        455 #> 10                       383 #>                                                                                                                    EstimatorScoreResult #> 1  <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots>, <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots> #> 2  <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots>, <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots> #> 3  <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots>, <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots> #> 4  <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots>, <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots> #> 5  <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots>, <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots> #> 6  <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots>, <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots> #> 7  <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots>, <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots> #> 8  <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots>, <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots> #> 9  <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots>, <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots> #> 10 <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots>, <S4 class 'EstimatorScoreResult' [package \"adestr\"] with 8 slots>"},{"path":"https://jan-imbi.github.io/adestr/articles/Introduction.html","id":"analyzing-datasets","dir":"Articles","previous_headings":"","what":"Analyzing datasets","title":"Introduction to adestr","text":"Next, let us look package can used calculate estimates data collected. first stage data trial might look like : results suggest recruiting 23 patients per group second stage. simulate 47 patients per group: Now, can use analyze function evaluate selection estimators complete dataset: estimates presented difference means two normal distributions. Keep mind difference μ=0.3\\mu=0.3 used simulation. Note median unbiased estimator performs well particular example, universally true.","code":"set.seed(321) dat <- data.frame(  endpoint = c(rnorm(56, .3, 1), rnorm(56, 0, 1)),  group = factor(rep(c(\"trt\", \"ctl\"),                     c(56,56)), levels = c(\"trt\", \"ctl\")),  stage = rep(1, 112) ) head(dat) #>      endpoint group stage #> 1  2.00490322   trt     1 #> 2 -0.41203856   trt     1 #> 3  0.02201509   trt     1 #> 4  0.18035098   trt     1 #> 5  0.17603938   trt     1 #> 6  0.56818377   trt     1 analyze(data = dat,         statistics = list(),         data_distribution = Normal(two_armed = TRUE),         design = get_example_design(two_armed = TRUE),         sigma = 1) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Observed number of stages:                                                     1 #> Observed n1 (group 1)                                                         56 #> Observed n1 (group 2)                                                         56 #> Observed n1 (total)                                                          112 #> Z1                                                                          1.75 #> Interim decision:                                       continue to second stage #> Calculated n2(Z1) (per group)                                           46.99923 #> Calculated c2(Z1)                                                           1.14 dat <- rbind(dat,              data.frame(                endpoint = c(rnorm(47, .3, 1), rnorm(47, 0, 1)),                group = factor(rep(c(\"trt\", \"ctl\"),                                   c(47, 47)), levels = c(\"trt\", \"ctl\")),                stage = rep(2, 94)              )) analyze(  data = dat,  statistics = c(    SampleMean(),    BiasReduced(),    PseudoRaoBlackwell(),    MedianUnbiasedStagewiseCombinationFunctionOrdering(),    StagewiseCombinationFunctionOrderingCI(),    StagewiseCombinationFunctionOrderingPValue()    ),  data_distribution = Normal(two_armed = TRUE),  sigma = 1,  design = get_example_design(two_armed = TRUE) ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Observed number of stages:                                                     2 #> Observed n1 (group 1)                                                         56 #> Observed n1 (group 2)                                                         56 #> Observed n1 (total)                                                          112 #> Z1                                                                          1.75 #> Interim decision:                                       continue to second stage #> Calculated n2(Z1) (per group)                                           46.99923 #> Calculated c2(Z1)                                                           1.14 #> Observed n2 (group 1)                                                         47 #> Observed n2 (group 2)                                                         47 #> Observed n2 (in total)                                                        94 #> Z2                                                                          2.71 #> Final test decision:                                                 reject null #>  #> Stage 2 results: #>  Sample mean:                                                           0.434684 #>  Bias reduced MLE (iterations=1):                                      0.4221533 #>  Pseudo Rao-Blackwellized:                                             0.2658506 #>  Median unbiased (SWCF ordering):                                      0.3047428 #>  SWCF ordering CI:                                       [0.04435513, 0.5484439] #>  SWCF ordering p-value:                                               0.01097266"},{"path":"https://jan-imbi.github.io/adestr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jan Meis. Author, maintainer. Martin Maechler. Copyright holder.            Original author monoSpl.c ('stats' package).","code":""},{"path":"https://jan-imbi.github.io/adestr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Meis, J, Pilz, M, Herrmann, C, Bokelmann, B, Rauch, G, Kieser, M. Point estimation, confidence intervals, P-values optimal adaptive two-stage designs normal endpoints. Statistics Medicine. 2024; 43(8): 1577–1603. doi:10.1002/sim.10020","code":"@Article{,   author = {Jan Meis and Maximilian Pilz and Carolin Herrmann and Björn Bokelmann and Geraldine Rauch and Meinhard Kieser},   title = {Point estimation, confidence intervals, and P-values for optimal adaptive two-stage designs with normal endpoints},   journal = {Statistics in Medicine},   volume = {43},   number = {8},   pages = {1577-1603},   keywords = {bias, confidence intervals, optimal adaptive designs, P-values, point estimation},   doi = {10.1002/sim.10020},   year = {2024}, }"},{"path":"https://jan-imbi.github.io/adestr/index.html","id":"adestr-","dir":"","previous_headings":"","what":"Estimation in Optimal Adaptive Two-Stage Designs","title":"Estimation in Optimal Adaptive Two-Stage Designs","text":"package implements methods evaluate performance characteristics various point interval estimators adaptive two-stage designs prespecified sample-size recalculation rules. , allows evaluation estimators real datasets, implements methods calculate p-values. Currently, works designs objects produced R-package adoptr, calculates optimal design parameters adaptive two-stage designs. introductory vignette covering common usecases given https://jan-imbi.github.io/adestr/articles/Introduction.html. package comes suite unit tests. code test cases can viewed : https://github.com/jan-imbi/adestr/tree/master/tests/testthat. authors assume responsibility correctness code results produced usage. Use risk. may also interested reference implementation looking https://github.com/jan-imbi/adestr/blob/master/R/reference_implementation.R. uses notation paper (doi.org/10.1002/sim.10020) may therefore easier understand first.","code":""},{"path":"https://jan-imbi.github.io/adestr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Estimation in Optimal Adaptive Two-Stage Designs","text":"can install development version adestr typing R console.","code":"remotes::install_github(\"https://github.com/jan-imbi/adestr\")"},{"path":"https://jan-imbi.github.io/adestr/index.html","id":"small-introductory-example","dir":"","previous_headings":"","what":"Small introductory example","title":"Estimation in Optimal Adaptive Two-Stage Designs","text":"quick example showing capabilities adestr. First, load adestr: , can evaluate performance estimator like :  can analyze dataset like : Please refer https://jan-imbi.github.io/adestr/articles/Introduction.html detailed introduction.","code":"library(adestr) #> Loading required package: adoptr evaluate_estimator(  score = MSE(),  estimator = SampleMean(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(),  mu = c(0, 0.3, 0.6),  sigma = 1 ) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                                           Sample mean #> Assumed sigma:                                                                 1 #> Assumed mu:                                                          0.0 0.3 0.6 #> Results: #>  Expectation:                                   -0.0352411  0.2816994  0.6355803 #>  Bias:                                       -0.03524110 -0.01830056  0.03558030 #>  Variance:                                      0.05558372 0.07330105 0.06590990 #>  MSE:                                           0.05682565 0.07363596 0.06717585  evaluate_estimator(  score = MSE(),  estimator = SampleMean(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(),  mu = seq(-0.7, 1.5, .05),  sigma = 1 ) |>    plot() set.seed(321) dat <- data.frame(  endpoint = c(rnorm(28, .2, 1), rnorm(28, 0, 1),               rnorm(23, .2, 1), rnorm(23, 0, 1)),  group = factor(rep(c(\"ctl\", \"trt\", \"ctl\", \"trt\"),                     c(28,28,23,23))),  stage = rep(c(1L, 2L), c(56, 46)) ) analyze(  data = dat,  statistics = get_example_statistics(),  data_distribution = Normal(two_armed = TRUE),  sigma = 1,  design = get_example_design() ) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                             Normal<two-armed> #> Observed number of stages:                                                     2 #> Observed n1 (group 1)                                                         28 #> Observed n1 (group 2)                                                         28 #> Observed n1 (total)                                                           56 #> Z1                                                                          1.75 #> Interim decision:                                       continue to second stage #> Calculated n2(Z1) (per group)                                           23.49151 #> Calculated c2(Z1)                                                           1.14 #> Observed n2 (group 1)                                                         23 #> Observed n2 (group 2)                                                         23 #> Observed n2 (in total)                                                        46 #> Z2                                                                          2.12 #> Final test decision:                                                 reject null #>  #> Stage 2 results: #>  Sample mean:                                                          0.5389012 #>  Pseudo Rao-Blackwellized:                                             0.3632916 #>  Median unbiased (LR test ordering):                                   0.5069941 #>  Bias reduced MLE (iterations=1):                                      0.5253942 #>  SWCF ordering CI:                                       [0.06264641, 0.7429735] #>  LR test ordering CI:                                       [0.2509094, 0.81829] #>  SWCF ordering p-value:                                               0.01097483 #>  LR test ordering p-value:                                          6.653031e-05"},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Performance scores for point and interval estimators — EstimatorScore-class","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"classes encode various metrics can used evaluate performance characteristics point interval estimators.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"","code":"Expectation()  Bias()  Variance()  MSE()  OverestimationProbability()  Coverage()  SoftCoverage(shrinkage = 1)  Width()  TestAgreement()  Centrality(interval = NULL)"},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"shrinkage shrinkage factor bump function. interval confidence interval respect centrality point estimator evaluated.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"object class EstimatorScore. class signals object can used evaluate_estimator function.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"label name performance score. Used printing methods.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"details-on-the-implemented-estimators","dir":"Reference","previous_headings":"","what":"Details on the implemented estimators","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"following, precise definitions performance scores implemented adestr given. end, let \\(\\hat{\\mu}\\) denote point estimator, (\\(\\hat{l}\\), \\(\\hat{u}\\)) interval estimator, denote expected value random variable \\(\\mathbb{E}\\), probability event \\(P\\), let \\(\\mu\\) real value underlying parameter estimated.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"scores-for-point-estimators-pointestimatorscore-","dir":"Reference","previous_headings":"","what":"Scores for point estimators (PointEstimatorScore):","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"Expectation(): \\(\\mathbb{E}[\\hat{\\mu}]\\) Bias(): \\(\\mathbb{E}[\\hat{\\mu} - \\mu]\\) Variance(): \\(\\mathbb{E}[(\\hat{\\mu} - \\mathbb{E}[\\hat{\\mu}])^2]\\) MSE(): \\(\\mathbb{E}[(\\hat{\\mu} - mu)^2]\\) OverestimationProbability(): \\(P(\\hat{\\mu} > \\mu)\\) Centrality(interval): \\(\\mathbb{E}[(\\hat{\\mu} - \\hat{l}) + (\\hat{\\mu} - \\hat{u}]\\)","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"scores-for-confidence-intervals-intervalestimatorscore-","dir":"Reference","previous_headings":"","what":"Scores for confidence intervals (IntervalEstimatorScore):","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"Coverage(): \\(P(\\hat{l} \\leq \\mu \\leq \\hat{u})\\) Width(): \\(\\mathbb{E}[\\hat{u} - \\hat{l}]\\) TestAgreement(): \\(P\\left( \\left(\\{0 < \\hat{l} \\text{ } (c_{1, e} < Z_1 \\text{ } c_{2}(Z_1) < Z_2 ) \\right) \\text{ } \\left(\\{\\hat{l} \\leq 0  \\text{ } ( Z_1 < c_{1, f} \\text{ } Z_2 \\leq c_{2}(Z_1))\\}\\right)\\right)\\)","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"","code":"evaluate_estimator(   score = MSE(),   estimator = SampleMean(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu = c(0, 0.3, 0.6),   sigma = 1,   exact = FALSE ) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Estimator:                                                           Sample mean #> Assumed sigma:                                                                 1 #> Assumed mu:                                                          0.0 0.3 0.6 #> Results: #>  Expectation:                                -0.02491922  0.30567290  0.62041636 #>  Bias:                                    -0.024919220  0.005672903  0.020416356 #>  Variance:                                      0.02779122 0.03777824 0.02790974 #>  MSE:                                           0.02841219 0.03781042 0.02832657 #>   evaluate_estimator(   score = Coverage(),   estimator = StagewiseCombinationFunctionOrderingCI(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu = c(0, 0.3),   sigma = 1,   exact = FALSE ) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Estimator:                                                      SWCF ordering CI #> Assumed sigma:                                                                 1 #> Assumed mu:                                                              0.0 0.3 #> Results: #>  Coverage:                                                   0.9500681 0.9499744 #>"},{"path":"https://jan-imbi.github.io/adestr/reference/IntervalEstimator-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Interval estimators — IntervalEstimator-class","title":"Interval estimators — IntervalEstimator-class","text":"parent class confidence intervals implemented package. Currently, confidence intervals parameter \\(\\mu\\) normal distribution implemented. Details methods calculating confidence intervals can found (upcoming paper).","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/IntervalEstimator-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interval estimators — IntervalEstimator-class","text":"","code":"IntervalEstimator(two_sided, l1, u1, l2, u2, label)  RepeatedCI(two_sided = TRUE)  StagewiseCombinationFunctionOrderingCI(two_sided = TRUE)  MLEOrderingCI(two_sided = TRUE)  LikelihoodRatioOrderingCI(two_sided = TRUE)  ScoreTestOrderingCI(two_sided = TRUE)  NeymanPearsonOrderingCI(two_sided = TRUE, mu0 = 0, mu1 = 0.4)  NaiveCI(two_sided = TRUE)"},{"path":"https://jan-imbi.github.io/adestr/reference/IntervalEstimator-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interval estimators — IntervalEstimator-class","text":"two_sided logical indicating whether confidence interval two-sided. l1 functional representation lower boundary interval early futility efficacy regions. u1 functional representation upper boundary interval early futility efficacy regions. l2 functional representation lower boundary interval continuation region. u2 functional representation upper boundary interval continuation region. label name estimator. Used printing methods. mu0 expected value normal distribution null hypothesis. mu1 expected value normal distribution null hypothesis.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/IntervalEstimator-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interval estimators — IntervalEstimator-class","text":"object class IntervalEstimator. class signals object can supplied evaluate_estimator analyze functions.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/IntervalEstimator-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Interval estimators — IntervalEstimator-class","text":"implemented confidence intervals : MLEOrderingCI() LikelihoodRatioOrderingCI() ScoreTestOrderingCI() StagewiseCombinationFunctionOrderingCI() confidence intervals constructed specifying ordering sample space finding value \\(\\mu\\), observed sample \\(\\alpha/2\\) ((\\(1-\\alpha/2\\))) quantile sample space according chosen ordering. implemented orderings based work presented (Emerson Fleming 1990) , (Sections 8.4 Jennison Turnbull 1999) , (Sections 4.1.1 8.2.1 Wassmer Brannath 2016) .","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/IntervalEstimator-class.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Interval estimators — IntervalEstimator-class","text":"Emerson SS, Fleming TR (1990). “Parameter estimation following group sequential hypothesis testing.” Biometrika, 77(4), 875–892. doi:10.2307/2337110 . Jennison C, Turnbull BW (1999). Group Sequential Methods Applications Clinical Trials, 1 edition. Chapman Hall/CRC., New York. doi:10.1201/9780367805326 . Wassmer G, Brannath W (2016). Group Sequential Confirmatory Adaptive Designs Clinical Trials, 1 edition. Springer, Cham, Switzerland. doi:10.1007/978-3-319-32562-0 .","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/IntervalEstimator-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interval estimators — IntervalEstimator-class","text":"","code":"# This is the definition of the 'naive' confidence interval for one-armed trials IntervalEstimator(   two_sided = TRUE,   l1 = \\(smean1, n1, sigma, ...) smean1 - qnorm(.95, sd = sigma/sqrt(n1)),   u1 = \\(smean1, n1, sigma, ...) smean1 + qnorm(.95, sd = sigma/sqrt(n1)),   l2 = \\(smean1, smean2, n1, n2, sigma, ...) smean2 - qnorm(.95, sd = sigma/sqrt(n1 + n2)),   u2 = \\(smean1, smean2, n1, n2, sigma, ...) smean2 + qnorm(.95, sd = sigma/sqrt(n1 + n2)),   label=\"My custom CI\") #> My custom CI"},{"path":"https://jan-imbi.github.io/adestr/reference/NormalPrior.html","id":null,"dir":"Reference","previous_headings":"","what":"Normal prior distribution for the parameter mu — NormalPrior","title":"Normal prior distribution for the parameter mu — NormalPrior","text":"Normal prior distribution parameter mu","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/NormalPrior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normal prior distribution for the parameter mu — NormalPrior","text":"","code":"NormalPrior(mu = 0, sigma = 1)"},{"path":"https://jan-imbi.github.io/adestr/reference/NormalPrior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normal prior distribution for the parameter mu — NormalPrior","text":"mu mean prior distribution. sigma standard deviation prior distribution.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/NormalPrior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normal prior distribution for the parameter mu — NormalPrior","text":"object class NormalPrior. object can supplied argument mu evaluate_estimator function calculate performance scores weighted prior.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/NormalPrior.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Normal prior distribution for the parameter mu — NormalPrior","text":"","code":"NormalPrior(mu = 0, sigma = 1) #> NormalPrior<mu=0;sigma=1>"},{"path":"https://jan-imbi.github.io/adestr/reference/PValue-class.html","id":null,"dir":"Reference","previous_headings":"","what":"P-values — PValue-class","title":"P-values — PValue-class","text":"parent class p-values implemented package. Details methods calculating p-values can found (upcoming paper).","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PValue-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"P-values — PValue-class","text":"","code":"PValue(g1, g2, label)  LinearShiftRepeatedPValue(wc1f = 0, wc1e = 1/2, wc2 = 1/2)  MLEOrderingPValue()  LikelihoodRatioOrderingPValue()  ScoreTestOrderingPValue()  StagewiseCombinationFunctionOrderingPValue()  NeymanPearsonOrderingPValue(mu0 = 0, mu1 = 0.4)  NaivePValue()"},{"path":"https://jan-imbi.github.io/adestr/reference/PValue-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"P-values — PValue-class","text":"g1 functional representation p-value early futility efficacy regions. g2 functional representation p-value continuation region. label name p-value. Used printing methods. wc1f slope futility boundary change. wc1e slope efficacy boundary change. wc2 slope c2 boundary change. mu0 expected value normal distribution null hypothesis. mu1 expected value normal distribution null hypothesis.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PValue-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"P-values — PValue-class","text":"object class PValue. class signals object can supplied analyze function.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PValue-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"P-values — PValue-class","text":"implemented p-values : MLEOrderingPValue() LikelihoodRatioOrderingPValue() ScoreTestOrderingPValue() StagewiseCombinationFunctionOrderingPValue() p-values calculated specifying ordering sample space calculating probability random sample null hypothesis larger observed sample. implemented orderings based work presented (Emerson Fleming 1990) , (Sections 8.4 Jennison Turnbull 1999) , (Sections 4.1.1 8.2.1 Wassmer Brannath 2016) .","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PValue-class.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"P-values — PValue-class","text":"Emerson SS, Fleming TR (1990). “Parameter estimation following group sequential hypothesis testing.” Biometrika, 77(4), 875–892. doi:10.2307/2337110 . Jennison C, Turnbull BW (1999). Group Sequential Methods Applications Clinical Trials, 1 edition. Chapman Hall/CRC., New York. doi:10.1201/9780367805326 . Wassmer G, Brannath W (2016). Group Sequential Confirmatory Adaptive Designs Clinical Trials, 1 edition. Springer, Cham, Switzerland. doi:10.1007/978-3-319-32562-0 .","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/PValue-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"P-values — PValue-class","text":"","code":"# This is the definition of a 'naive' p-value based on a Z-test for a one-armed trial PValue(   g1 = \\(smean1, n1, sigma, ...) pnorm(smean1*sqrt(n1)/sigma, lower.tail=FALSE),   g2 = \\(smean1, smean2, n1, n2, ...) pnorm((n1 * smean1 + n2 * smean2)/(n1 + n2) *                                         sqrt(n1+n2)/sigma, lower.tail=FALSE),   label=\"My custom p-value\") #> My custom p-value"},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Point estimators — PointEstimator-class","title":"Point estimators — PointEstimator-class","text":"parent class point estimators implemented package. Currently, estimators parameter \\(\\mu\\) normal distribution implemented.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Point estimators — PointEstimator-class","text":"","code":"PointEstimator(g1, g2, label)  SampleMean()  FirstStageSampleMean()  WeightedSampleMean(w1 = 0.5)  AdaptivelyWeightedSampleMean(w1 = 1/sqrt(2))  MinimizePeakVariance()  BiasReduced(iterations = 1L)  RaoBlackwell()  PseudoRaoBlackwell()  MidpointStagewiseCombinationFunctionOrderingCI()  MidpointMLEOrderingCI()  MidpointLikelihoodRatioOrderingCI()  MidpointScoreTestOrderingCI()  MidpointNeymanPearsonOrderingCI()  MedianUnbiasedStagewiseCombinationFunctionOrdering()  MedianUnbiasedMLEOrdering()  MedianUnbiasedLikelihoodRatioOrdering()  MedianUnbiasedScoreTestOrdering()  MedianUnbiasedNeymanPearsonOrdering(mu0 = 0, mu1 = 0.4)"},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Point estimators — PointEstimator-class","text":"g1 functional representation estimator early futility efficacy regions. g2 functional representation estimator continuation region. label name estimator. Used printing methods. w1 weight first-stage data. iterations number bias reduction iterations. Defaults 1. mu0 expected value normal distribution null hypothesis. mu1 expected value normal distribution null hypothesis.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Point estimators — PointEstimator-class","text":"object class PointEstimator. class signals object can supplied evaluate_estimator analyze functions.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Point estimators — PointEstimator-class","text":"Details point estimators can found (upcoming paper).","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"sample-mean-samplemean-","dir":"Reference","previous_headings":"","what":"Sample Mean (SampleMean())","title":"Point estimators — PointEstimator-class","text":"sample mean maximum likelihood estimator mean probably 'straightforward' implemented estimators.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"fixed-weighted-sample-means-weightedsamplemean-","dir":"Reference","previous_headings":"","what":"Fixed weighted sample means (WeightedSampleMean())","title":"Point estimators — PointEstimator-class","text":"first- second-stage (available) sample means combined via fixed, predefined weights. See (Brannath et al. 2006)  (Section 8.3.2 Wassmer Brannath 2016) .","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"adaptively-weighted-sample-means-adaptivelyweightedsamplemean-","dir":"Reference","previous_headings":"","what":"Adaptively weighted sample means (AdaptivelyWeightedSampleMean())","title":"Point estimators — PointEstimator-class","text":"first- second-stage (available) sample means combined via combination fixed adaptively modified weights depend standard error. See (Section 8.3.4 Wassmer Brannath 2016) .","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"minimizing-peak-variance-in-adaptively-weighted-sample-means-minimizepeakvariance-","dir":"Reference","previous_headings":"","what":"Minimizing peak variance in adaptively weighted sample means (MinimizePeakVariance())","title":"Point estimators — PointEstimator-class","text":"estimator, weights adaptively weighted sample mean chosen minimize variance estimator value \\(\\mu\\) maximizes expected sample size.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"-pseudo-rao-blackwell-estimators-raoblackwell-and-pseudoraoblackwell-","dir":"Reference","previous_headings":"","what":"(Pseudo) Rao-Blackwell estimators (RaoBlackwell and PseudoRaoBlackwell)","title":"Point estimators — PointEstimator-class","text":"conditional expectation first-stage sample mean given overall sample mean second-stage sample size. See (Emerson Kittelson 1997) .","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"a-bias-reduced-estimator-biasreduced-","dir":"Reference","previous_headings":"","what":"A bias-reduced estimator (BiasReduced())","title":"Point estimators — PointEstimator-class","text":"estimator calculated subtracting estimate bias MLE. See (Whitehead 1986) .","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"median-unbiased-estimators","dir":"Reference","previous_headings":"","what":"Median-unbiased estimators","title":"Point estimators — PointEstimator-class","text":"implemented median-unbiased estimators : MedianUnbiasedMLEOrdering() MedianUnbiasedLikelihoodRatioOrdering() MedianUnbiasedScoreTestOrdering() MedianUnbiasedStagewiseCombinationFunctionOrdering() estimators constructed specifying ordering sample space finding value \\(\\mu\\), observed sample median sample space according chosen ordering. implemented orderings based work presented (Emerson Fleming 1990) , (Sections 8.4 Jennison Turnbull 1999) , (Sections 4.1.1 8.2.1 Wassmer Brannath 2016) .","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Point estimators — PointEstimator-class","text":"Brannath W, König F, Bauer P (2006). “Estimation flexible two stage designs.” Statistics Medicine, 25(19), 3366-3381. doi:10.1002/sim.2258 . Emerson SS, Fleming TR (1990). “Parameter estimation following group sequential hypothesis testing.” Biometrika, 77(4), 875–892. doi:10.2307/2337110 . Emerson SS, Kittelson JM (1997). “computationally simpler algorithm UMVUE normal mean following group sequential trial.” Biometrics, 53(1), 365–369. doi:10.2307/2533122 . Jennison C, Turnbull BW (1999). Group Sequential Methods Applications Clinical Trials, 1 edition. Chapman Hall/CRC., New York. doi:10.1201/9780367805326 . Wassmer G, Brannath W (2016). Group Sequential Confirmatory Adaptive Designs Clinical Trials, 1 edition. Springer, Cham, Switzerland. doi:10.1007/978-3-319-32562-0 . Whitehead J (1986). “bias maximum likelihood estimation following sequential test.” Biometrika, 73(3), 573–581. doi:10.2307/2336521 .","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Point estimators — PointEstimator-class","text":"","code":"PointEstimator(g1 = \\(smean1, ...) smean1,g2 = \\(smean2, ...) smean2, label=\"My custom estimator\") #> My custom estimator"},{"path":"https://jan-imbi.github.io/adestr/reference/Statistic-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Statistics and Estimators of the adestr package — Statistic-class","title":"Statistics and Estimators of the adestr package — Statistic-class","text":"Statistic class parent class classes Estimator PValue. Estimator class parent classes PointEstimator ConfidenceInterval.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/Statistic-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Statistics and Estimators of the adestr package — Statistic-class","text":"label name statistic. Used printing methods.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/Statistic-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Statistics and Estimators of the adestr package — Statistic-class","text":"object class Statistic. class signals object can supplied analyze function.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/Statistic-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Statistics and Estimators of the adestr package — Statistic-class","text":"function analyze can used calculate value Statistic given dataset. function evaluate_estimator can used evaluate distributional quantities Estimator like MSE PointEstimator Coverage ConfidenceInterval.","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/TwoStageDesignWithCache.html","id":null,"dir":"Reference","previous_headings":"","what":"TwoStageDesignWithCache constructor function — TwoStageDesignWithCache","title":"TwoStageDesignWithCache constructor function — TwoStageDesignWithCache","text":"Creates object class TwoStageDesignWithCache. object stores precalculated spline paramters n2 c2 functions, allows quicker evaluation.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/TwoStageDesignWithCache.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"TwoStageDesignWithCache constructor function — TwoStageDesignWithCache","text":"","code":"TwoStageDesignWithCache(design)"},{"path":"https://jan-imbi.github.io/adestr/reference/TwoStageDesignWithCache.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"TwoStageDesignWithCache constructor function — TwoStageDesignWithCache","text":"design object class TwoStageDesign","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/UniformPrior.html","id":null,"dir":"Reference","previous_headings":"","what":"Uniform prior distribution for the parameter mu — UniformPrior","title":"Uniform prior distribution for the parameter mu — UniformPrior","text":"Uniform prior distribution parameter mu","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/UniformPrior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Uniform prior distribution for the parameter mu — UniformPrior","text":"","code":"UniformPrior(min = -1, max = 1)"},{"path":"https://jan-imbi.github.io/adestr/reference/UniformPrior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Uniform prior distribution for the parameter mu — UniformPrior","text":"min minimum support interval. max maximum support interval.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/UniformPrior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Uniform prior distribution for the parameter mu — UniformPrior","text":"object class UniformPrior. object can supplied argument mu evaluate_estimator function calculate performance scores weighted prior.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/UniformPrior.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Uniform prior distribution for the parameter mu — UniformPrior","text":"","code":"UniformPrior(min = -1, max = 1) #> UniformPrior<min=-1;max=1>"},{"path":"https://jan-imbi.github.io/adestr/reference/adestr.html","id":null,"dir":"Reference","previous_headings":"","what":"adestr — adestr","title":"adestr — adestr","text":"Point estimates, confidence intervals, p-values optimal adaptive two-stage designs.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/adestr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"adestr — adestr","text":"package implements methods evaluate performance characteristics various point interval estimators optimal adaptive two-stage designs. Specifically, package written interface trial designs created adoptr package (Kunzmann et al. 2021; Pilz et al. 2021) . Apart priori evaluation performance characteristics, package also allows calculation values estimators given real datasets, implements methods calculate p-values.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/adestr.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"adestr — adestr","text":"Kunzmann K, Pilz M, Herrmann C, Rauch G, Kieser M (2021). “adoptr package: Adaptive Optimal Designs Clinical Trials R.” Journal Statistical Software, 98(9), 1–21. doi:10.18637/jss.v098.i09 . Pilz M, Kunzmann K, Herrmann C, Rauch G, Kieser M (2021). “Optimal planning adaptive two-stage designs.” Statistics Medicine, 40(13), 3196-3213. doi:10.1002/sim.8953 .","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/adestr.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"adestr — adestr","text":"Maintainer: Jan Meis meis@imbi.uni-heidelberg.de (ORCID) contributors: Martin Maechler maechler@stat.math.ethz.ch (ORCID) (Original author monoSpl.c ('stats' package).) [copyright holder]","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/analyze.html","id":null,"dir":"Reference","previous_headings":"","what":"Analyze a dataset — analyze","title":"Analyze a dataset — analyze","text":"analyze function can used calculate values list point estimators, confidence intervals, p-values given dataset.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/analyze.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analyze a dataset — analyze","text":"","code":"analyze(   data,   statistics = list(),   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'data.frame' analyze(   data,   statistics = list(),   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )"},{"path":"https://jan-imbi.github.io/adestr/reference/analyze.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Analyze a dataset — analyze","text":"data data.frame containing data analyzed. statistics list objects class PointEstimator, ConfidenceInterval PValue. data_distribution object class Normal Student. use_full_twoarm_sampling_distribution logical indicating whether estimator intended used full sampling distribution two-armed trial. design object class TwoStageDesign. sigma assumed standard deviation. exact logical indicating usage exact n2 function.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/analyze.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Analyze a dataset — analyze","text":"Results object containing values statistics applied data.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/analyze.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Analyze a dataset — analyze","text":"Note adestr, statistics codes functions stage-wise sample means (stage-wise sample variances data_distribution Student). first-step, data summarized produce parameters. , list statistics evaluated values parameters. output analyze function also displays information hypothesis test interim decision. statistics list empty, information displayed.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/analyze.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Analyze a dataset — analyze","text":"","code":"set.seed(123) dat <- data.frame(   endpoint = c(rnorm(28, 0.3)),   stage = rep(1, 28) ) analyze(data = dat,         statistics = list(),         data_distribution = Normal(FALSE),         design = get_example_design(),         sigma = 1) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Observed number of stages:                                                     1 #> Observed n1 (total)                                                           28 #> Z1                                                                           1.3 #> Interim decision:                                       continue to second stage #> Calculated n2(Z1) (per group)                                           32.21129 #> Calculated c2(Z1)                                                           1.71 #>   # The results suggest recruiting 32 patients for the second stage dat <- rbind(   dat,   data.frame(     endpoint = rnorm(32, mean = 0.3),     stage = rep(2, 32))) analyze(data = dat,         statistics = get_example_statistics(),         data_distribution = Normal(FALSE),         design = get_example_design(),         sigma = 1) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Observed number of stages:                                                     2 #> Observed n1 (total)                                                           28 #> Z1                                                                           1.3 #> Interim decision:                                       continue to second stage #> Calculated n2(Z1) (per group)                                           32.21129 #> Calculated c2(Z1)                                                           1.71 #> Observed n2 (in total)                                                        32 #> Z2                                                                          2.66 #> Final test decision:                                                 reject null #>  #> Stage 2 results: #>  Sample mean:                                                          0.3656173 #>  Pseudo Rao-Blackwellized:                                             0.3135628 #>  Median unbiased (LR test ordering):                                   0.3420742 #>  Bias reduced MLE (iterations=1):                                       0.357214 #>  SWCF ordering CI:                                       [0.04664821, 0.6142449] #>  LR test ordering CI:                                    [0.08992822, 0.6106096] #>  SWCF ordering p-value:                                               0.01321363 #>  LR test ordering p-value:                                           0.003551316 #>"},{"path":"https://jan-imbi.github.io/adestr/reference/c-EstimatorScoreResult-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResult-method","title":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResult-method","text":"Creates object class EstimatoreScoreResultList, basically list respective EstimatoreScoreResult objects.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/c-EstimatorScoreResult-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResult-method","text":"","code":"# S4 method for class 'EstimatorScoreResult' c(x, ...)"},{"path":"https://jan-imbi.github.io/adestr/reference/c-EstimatorScoreResult-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResult-method","text":"x object class EstimatorScoreResult. ... additional arguments passed along list function","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/c-EstimatorScoreResult-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResult-method","text":"object class EstimatoreScoreResultList.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/c-EstimatorScoreResultList-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResultList-method","title":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResultList-method","text":"Creates object class EstimatoreScoreResultList, basically list respective EstimatoreScoreResult objects.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/c-EstimatorScoreResultList-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResultList-method","text":"","code":"# S4 method for class 'EstimatorScoreResultList' c(x, ...)"},{"path":"https://jan-imbi.github.io/adestr/reference/c-EstimatorScoreResultList-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResultList-method","text":"x object class EstimatorScoreResult. ... additional arguments passed along list function","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/c-EstimatorScoreResultList-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResultList-method","text":"object class EstimatoreScoreResultList.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/c2_extrapol.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the second-stage critical value for a design with cached spline parameters — c2_extrapol","title":"Calculate the second-stage critical value for a design with cached spline parameters — c2_extrapol","text":"Also extrapolates results values outside [c1f, c1e].","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/c2_extrapol.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the second-stage critical value for a design with cached spline parameters — c2_extrapol","text":"","code":"c2_extrapol(design, x1)"},{"path":"https://jan-imbi.github.io/adestr/reference/c2_extrapol.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the second-stage critical value for a design with cached spline parameters — c2_extrapol","text":"design object class TwoStageDesignWithCache. x1 first-stage test statistic","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate performance characteristics of an estimator — evaluate_estimator-methods","title":"Evaluate performance characteristics of an estimator — evaluate_estimator-methods","text":"function evaluates EstimatorScore PointEstimator IntervalEstimator integrating sampling distribution.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate performance characteristics of an estimator — evaluate_estimator-methods","text":"","code":"# S4 method for class 'PointEstimatorScore,IntervalEstimator' evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for class 'IntervalEstimatorScore,PointEstimator' evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for class 'list,Estimator' evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for class 'Expectation,PointEstimator' evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for class 'Bias,PointEstimator' evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for class 'Variance,PointEstimator' evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for class 'MSE,PointEstimator' evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for class 'OverestimationProbability,PointEstimator' evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for class 'Coverage,IntervalEstimator' evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for class 'SoftCoverage,IntervalEstimator' evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for class 'Width,IntervalEstimator' evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for class 'TestAgreement,IntervalEstimator' evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for class 'TestAgreement,PValue' evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for class 'Centrality,PointEstimator' evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )"},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate performance characteristics of an estimator — evaluate_estimator-methods","text":"score performance measure evaluate. estimator object class PointEstimator, IntervalEstimator PValue. data_distribution object class Normal Student. use_full_twoarm_sampling_distribution logical indicating whether estimator intended used full sampling distribution two-armed trial. design object class TwoStageDesign. true_parameter true value parameter (used e.g. evaluating bias). mu expected value underlying normal distribution. sigma assumed standard deviation. tol relative tolerance. maxEval maximum number iterations. absError absolute tolerance. exact logical indicating usage exact n2 function. early_futility_part include early futility part integral. continuation_part include continuation part integral. early_efficacy_part include early efficacy part integral. conditional_integral treat integral conditional integral.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator-methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate performance characteristics of an estimator — evaluate_estimator-methods","text":"object class EstimatorScoreResult containing values evaluated EstimatorScore information setting calculated (e.g. estimator, data_distribution, design, mu, sigma).","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator-methods.html","id":"general","dir":"Reference","previous_headings":"","what":"General","title":"Evaluate performance characteristics of an estimator — evaluate_estimator-methods","text":"First, functional representation integrand created combining information EstimatorScore object (score) PointEstimator IntervalEstimator object (estimator). sampling distribution design determined TwoStageDesign object (design) DataDistribution object (data_distribution), well assumed parameters \\(\\mu\\) (mu) \\(\\sigma\\) (sigma). parameters control various details integration problem.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator-methods.html","id":"other-parameters","dir":"Reference","previous_headings":"","what":"Other parameters","title":"Evaluate performance characteristics of an estimator — evaluate_estimator-methods","text":"two-armed data_distribution, use_full_twoarm_sampling_distribution TRUE, sample means groups integrated independently. use_full_twoarm_sampling_distribution FALSE, difference sample means integrated. true_parameter controls parameters supposed estimated. usually mu, set sigma one interested estimating standard deviation. parameter exact set FALSE (default), continuous version second-stage sample-size function n2 used. Otherwise, integer valued version function used, though considerably slower. parameters early_futility_part, continuation_part early_efficacy_part control parts sample-space integrated (default TRUE). can used conjunction parameter conditional_integral, enables calculation expected value performance score conditional reaching selected integration regions. Lastly, paramters tol, maxEval, absError control integration accuracy. handed hcubature function.","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate performance characteristics of an estimator — evaluate_estimator-methods","text":"","code":"evaluate_estimator(   score = MSE(),   estimator = SampleMean(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu = c(0, 0.3, 0.6),   sigma = 1,   exact = FALSE ) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Estimator:                                                           Sample mean #> Assumed sigma:                                                                 1 #> Assumed mu:                                                          0.0 0.3 0.6 #> Results: #>  Expectation:                                -0.02491922  0.30567290  0.62041636 #>  Bias:                                    -0.024919220  0.005672903  0.020416356 #>  Variance:                                      0.02779122 0.03777824 0.02790974 #>  MSE:                                           0.02841219 0.03781042 0.02832657 #>   evaluate_estimator(   score = Coverage(),   estimator = StagewiseCombinationFunctionOrderingCI(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu = c(0, 0.3),   sigma = 1,   exact = FALSE ) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Estimator:                                                      SWCF ordering CI #> Assumed sigma:                                                                 1 #> Assumed mu:                                                              0.0 0.3 #> Results: #>  Coverage:                                                   0.9500681 0.9499744 #>"},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate performance characteristics of an estimator — evaluate_estimator","title":"Evaluate performance characteristics of an estimator — evaluate_estimator","text":"function evaluates EstimatorScore PointEstimator IntervalEstimator integrating sampling distribution.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate performance characteristics of an estimator — evaluate_estimator","text":"","code":"evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )"},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate performance characteristics of an estimator — evaluate_estimator","text":"score performance measure evaluate. estimator object class PointEstimator, IntervalEstimator PValue. data_distribution object class Normal Student. use_full_twoarm_sampling_distribution logical indicating whether estimator intended used full sampling distribution two-armed trial. design object class TwoStageDesign. true_parameter true value parameter (used e.g. evaluating bias). mu expected value underlying normal distribution. sigma assumed standard deviation. tol relative tolerance. maxEval maximum number iterations. absError absolute tolerance. exact logical indicating usage exact n2 function. early_futility_part include early futility part integral. continuation_part include continuation part integral. early_efficacy_part include early efficacy part integral. conditional_integral treat integral conditional integral.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate performance characteristics of an estimator — evaluate_estimator","text":"object class EstimatorScoreResult containing values evaluated EstimatorScore information setting calculated (e.g. estimator, data_distribution, design, mu, sigma).","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator.html","id":"general","dir":"Reference","previous_headings":"","what":"General","title":"Evaluate performance characteristics of an estimator — evaluate_estimator","text":"First, functional representation integrand created combining information EstimatorScore object (score) PointEstimator IntervalEstimator object (estimator). sampling distribution design determined TwoStageDesign object (design) DataDistribution object (data_distribution), well assumed parameters \\(\\mu\\) (mu) \\(\\sigma\\) (sigma). parameters control various details integration problem.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator.html","id":"other-parameters","dir":"Reference","previous_headings":"","what":"Other parameters","title":"Evaluate performance characteristics of an estimator — evaluate_estimator","text":"two-armed data_distribution, use_full_twoarm_sampling_distribution TRUE, sample means groups integrated independently. use_full_twoarm_sampling_distribution FALSE, difference sample means integrated. true_parameter controls parameters supposed estimated. usually mu, set sigma one interested estimating standard deviation. parameter exact set FALSE (default), continuous version second-stage sample-size function n2 used. Otherwise, integer valued version function used, though considerably slower. parameters early_futility_part, continuation_part early_efficacy_part control parts sample-space integrated (default TRUE). can used conjunction parameter conditional_integral, enables calculation expected value performance score conditional reaching selected integration regions. Lastly, paramters tol, maxEval, absError control integration accuracy. handed hcubature function.","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate performance characteristics of an estimator — evaluate_estimator","text":"","code":"evaluate_estimator(   score = MSE(),   estimator = SampleMean(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu = c(0, 0.3, 0.6),   sigma = 1,   exact = FALSE ) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Estimator:                                                           Sample mean #> Assumed sigma:                                                                 1 #> Assumed mu:                                                          0.0 0.3 0.6 #> Results: #>  Expectation:                                -0.02491922  0.30567290  0.62041636 #>  Bias:                                    -0.024919220  0.005672903  0.020416356 #>  Variance:                                      0.02779122 0.03777824 0.02790974 #>  MSE:                                           0.02841219 0.03781042 0.02832657 #>   evaluate_estimator(   score = Coverage(),   estimator = StagewiseCombinationFunctionOrderingCI(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu = c(0, 0.3),   sigma = 1,   exact = FALSE ) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Estimator:                                                      SWCF ordering CI #> Assumed sigma:                                                                 1 #> Assumed mu:                                                              0.0 0.3 #> Results: #>  Coverage:                                                   0.9500681 0.9499744 #>"},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_scenarios_parallel.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate different scenarios in parallel — evaluate_scenarios_parallel","title":"Evaluate different scenarios in parallel — evaluate_scenarios_parallel","text":"function takes list lists scores, list lists estimators, lists lists various design parameters. possible combination elements respective sublists used create separate scenarios. scenarios evaluated independelty , allowing parallelization via future framework. scenario, one call evaluate_estimator function made.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_scenarios_parallel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate different scenarios in parallel — evaluate_scenarios_parallel","text":"","code":"evaluate_scenarios_parallel(   score_lists,   estimator_lists,   data_distribution_lists,   use_full_twoarm_sampling_distribution_lists,   design_lists,   true_parameter_lists,   mu_lists,   sigma_lists,   tol_lists,   maxEval_lists,   absError_lists,   exact_lists,   early_futility_part_lists,   continuation_part_lists,   early_efficacy_part_lists,   conditional_integral_lists )"},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_scenarios_parallel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate different scenarios in parallel — evaluate_scenarios_parallel","text":"score_lists list lists estimator scores. estimator_lists list lists estimators. data_distribution_lists list lists data distributions. use_full_twoarm_sampling_distribution_lists list lists use_full_twoarm_sampling_distribution_lists parameters. design_lists list lists designs. true_parameter_lists list lists true parameters. mu_lists list lists mu vectors. sigma_lists list lists sigma values. tol_lists list lists relative tolerances. maxEval_lists list lists maxEval boundaries. absError_lists list lists absError boundaries. exact_lists list lists `exact` parameters. early_futility_part_lists list lists `early_futility_part_lists` parameters. continuation_part_lists list lists `continuation_part_lists` parameters. early_efficacy_part_lists list lists `early_efficacy_part_lists` parameters. conditional_integral_lists list lists `conditional_integral_lists` parameters.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_scenarios_parallel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate different scenarios in parallel — evaluate_scenarios_parallel","text":"list data.frames containing results respective scenarios.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_scenarios_parallel.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluate different scenarios in parallel — evaluate_scenarios_parallel","text":"Concretely, cross product first sublist scores first sublist estimators parameters calculated. cross product second sublist scores, estimators design parameters calculated. cross products together make set scenarios. combinations say first sublist scores second sublist estimators considered.","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_scenarios_parallel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate different scenarios in parallel — evaluate_scenarios_parallel","text":"","code":"res <-evaluate_scenarios_parallel(  score_lists = list(c(MSE(), OverestimationProbability())),  estimator_lists =  list(c(SampleMean(), FirstStageSampleMean())),  data_distribution_lists = list(c(Normal(FALSE), Normal(TRUE))),  design_lists =  list(c(get_example_design())),  mu_lists = list(c(-1, 0, 1)),  sigma_lists = list(1) )"},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_design.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate an exemplary adaptive design — get_example_design","title":"Generate an exemplary adaptive design — get_example_design","text":"design optimized minimize expected sample size alternative hypothesis one-armed trial. boundaries chosen control type error 0.025 normally distributed test statistic (.e. known variance). alternative hypothesis mu=0.4, overall power 80%.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate an exemplary adaptive design — get_example_design","text":"","code":"get_example_design(two_armed = FALSE, label = NULL)"},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate an exemplary adaptive design — get_example_design","text":"two_armed (logical) determins whether design one- two-armed trials. label (optional) label assigned design.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_design.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate an exemplary adaptive design — get_example_design","text":"exemplary design class TwoStageDesign. object contains information sample size recalculation rule n2, futility efficacy boundaries c1f c1e second-stage rejection boundary c2.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_design.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate an exemplary adaptive design — get_example_design","text":"","code":"get_example_design() #> TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40>"},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_statistics.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a list of estimators and p-values to use in examples — get_example_statistics","title":"Generate a list of estimators and p-values to use in examples — get_example_statistics","text":"function generates list objects class PointEstimator, IntervalEstimators, PValues use examples analyze function.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_statistics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a list of estimators and p-values to use in examples — get_example_statistics","text":"","code":"get_example_statistics(   point_estimators = TRUE,   interval_estimators = TRUE,   p_values = TRUE )"},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_statistics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a list of estimators and p-values to use in examples — get_example_statistics","text":"point_estimators logical indicating whether point estimators included output list interval_estimators logical indicating whether interval estimators included output list p_values logical indicating whether p-values included output list","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_statistics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a list of estimators and p-values to use in examples — get_example_statistics","text":"list PointEstimators, IntervalEstimators PValue.","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_statistics.html","id":"point-estimators","dir":"Reference","previous_headings":"","what":"Point estimators","title":"Generate a list of estimators and p-values to use in examples — get_example_statistics","text":"following PointEstimators included: SampleMean PseudoRaoBlackwell MedianUnbiasedLikelihoodRatioOrdering BiasReduced","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_statistics.html","id":"confidence-intervals","dir":"Reference","previous_headings":"","what":"Confidence intervals","title":"Generate a list of estimators and p-values to use in examples — get_example_statistics","text":"following IntervalEstimators included: StagewiseCombinationFunctionOrderingCI LikelihoodRatioOrderingCI","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_statistics.html","id":"p-values","dir":"Reference","previous_headings":"","what":"P-Values","title":"Generate a list of estimators and p-values to use in examples — get_example_statistics","text":"following PValues included: StagewiseCombinationFunctionOrderingPValue LikelihoodRatioOrderingPValue","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_statistics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a list of estimators and p-values to use in examples — get_example_statistics","text":"","code":"set.seed(123) dat <- data.frame(   endpoint = c(rnorm(28, 0.3)),   stage = rep(1, 28) ) analyze(data = dat,         statistics = list(),         data_distribution = Normal(FALSE),         design = get_example_design(),         sigma = 1) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Observed number of stages:                                                     1 #> Observed n1 (total)                                                           28 #> Z1                                                                           1.3 #> Interim decision:                                       continue to second stage #> Calculated n2(Z1) (per group)                                           32.21129 #> Calculated c2(Z1)                                                           1.71 #>   # The results suggest recruiting 32 patients for the second stage dat <- rbind(   dat,   data.frame(     endpoint = rnorm(32, mean = 0.3),     stage = rep(2, 32))) analyze(data = dat,         statistics = get_example_statistics(),         data_distribution = Normal(FALSE),         design = get_example_design(),         sigma = 1) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Observed number of stages:                                                     2 #> Observed n1 (total)                                                           28 #> Z1                                                                           1.3 #> Interim decision:                                       continue to second stage #> Calculated n2(Z1) (per group)                                           32.21129 #> Calculated c2(Z1)                                                           1.71 #> Observed n2 (in total)                                                        32 #> Z2                                                                          2.66 #> Final test decision:                                                 reject null #>  #> Stage 2 results: #>  Sample mean:                                                          0.3656173 #>  Pseudo Rao-Blackwellized:                                             0.3135628 #>  Median unbiased (LR test ordering):                                   0.3420742 #>  Bias reduced MLE (iterations=1):                                       0.357214 #>  SWCF ordering CI:                                       [0.04664821, 0.6142449] #>  LR test ordering CI:                                    [0.08992822, 0.6106096] #>  SWCF ordering p-value:                                               0.01321363 #>  LR test ordering p-value:                                           0.003551316 #>"},{"path":"https://jan-imbi.github.io/adestr/reference/get_stagewise_estimators.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional representations of an estimator or p-value — get_stagewise_estimators","title":"Conditional representations of an estimator or p-value — get_stagewise_estimators","text":"generic determines functional representations point interval estimators p-values. functions returned two parts, one part calculate values conditional early futility efficacy stops (.e. second stage mean sample size available), one conditional continuation second stage.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_stagewise_estimators.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditional representations of an estimator or p-value — get_stagewise_estimators","text":"","code":"get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'VirtualPointEstimator,ANY' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'VirtualPValue,ANY' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'VirtualIntervalEstimator,ANY' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'PointEstimator,Student' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'PValue,Student' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'IntervalEstimator,Student' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'VirtualPointEstimator,Student' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'VirtualIntervalEstimator,Student' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'VirtualPValue,Student' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'PointEstimator,DataDistribution' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'PValue,DataDistribution' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'IntervalEstimator,DataDistribution' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'AdaptivelyWeightedSampleMean,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'MinimizePeakVariance,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'BiasReduced,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'RaoBlackwell,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'PseudoRaoBlackwell,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'RepeatedCI,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'LinearShiftRepeatedPValue,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'MLEOrderingPValue,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'LikelihoodRatioOrderingPValue,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'ScoreTestOrderingPValue,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'StagewiseCombinationFunctionOrderingPValue,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'NeymanPearsonOrderingPValue,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'NaivePValue,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'StagewiseCombinationFunctionOrderingCI,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'MLEOrderingCI,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'LikelihoodRatioOrderingCI,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'ScoreTestOrderingCI,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'NeymanPearsonOrderingCI,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'NaiveCI,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'MidpointStagewiseCombinationFunctionOrderingCI,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'MidpointMLEOrderingCI,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'MidpointLikelihoodRatioOrderingCI,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'MidpointScoreTestOrderingCI,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'MidpointNeymanPearsonOrderingCI,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'MedianUnbiasedStagewiseCombinationFunctionOrdering,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'MedianUnbiasedMLEOrdering,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'MedianUnbiasedLikelihoodRatioOrdering,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'MedianUnbiasedScoreTestOrdering,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for class 'MedianUnbiasedNeymanPearsonOrdering,Normal' get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )"},{"path":"https://jan-imbi.github.io/adestr/reference/get_stagewise_estimators.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conditional representations of an estimator or p-value — get_stagewise_estimators","text":"estimator object class PointEstimator, IntervalEstimator PValue. data_distribution object class Normal Student. use_full_twoarm_sampling_distribution logical indicating whether estimator intended used full sampling distribution two-armed trial. design object class TwoStageDesign. sigma assumed standard deviation. exact logical indicating usage exact n2 function.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_stagewise_estimators.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conditional representations of an estimator or p-value — get_stagewise_estimators","text":"list conditional functional representations (one stage trial might end) estimator p-value.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_stagewise_estimators.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditional representations of an estimator or p-value — get_stagewise_estimators","text":"","code":"get_stagewise_estimators(   estimator = SampleMean(),   data_distribution = Normal(FALSE),   use_full_twoarm_sampling_distribution = FALSE,   design = get_example_design(),   sigma = 1,   exact = FALSE ) #> $g1 #> function (smean1, ...)  #> smean1 #> <bytecode: 0x55dc2e78e468> #> <environment: 0x55dc2ef01f78> #>  #> $g2 #> function (smean1, smean2, n1, n2, ...)  #> (n1 * smean1 + n2 * smean2)/(n1 + n2) #> <bytecode: 0x55dc2e78e970> #> <environment: 0x55dc2ef01f78> #>"},{"path":"https://jan-imbi.github.io/adestr/reference/get_statistics_from_paper.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate the list of estimators and p-values that were used in the paper — get_statistics_from_paper","title":"Generate the list of estimators and p-values that were used in the paper — get_statistics_from_paper","text":"Generate list estimators p-values used paper","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_statistics_from_paper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate the list of estimators and p-values that were used in the paper — get_statistics_from_paper","text":"","code":"get_statistics_from_paper(   point_estimators = TRUE,   interval_estimators = TRUE,   p_values = TRUE )"},{"path":"https://jan-imbi.github.io/adestr/reference/get_statistics_from_paper.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate the list of estimators and p-values that were used in the paper — get_statistics_from_paper","text":"point_estimators logical indicating whether point estimators included output list interval_estimators logical indicating whether interval estimators included output list p_values logical indicating whether p-values included output list","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_statistics_from_paper.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate the list of estimators and p-values that were used in the paper — get_statistics_from_paper","text":"list PointEstimators, IntervalEstimators PValue.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_statistics_from_paper.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate the list of estimators and p-values that were used in the paper — get_statistics_from_paper","text":"","code":"set.seed(123) dat <- data.frame(   endpoint = c(rnorm(28, 0.3)),   stage = rep(1, 28) ) analyze(data = dat,         statistics = list(),         data_distribution = Normal(FALSE),         design = get_example_design(),         sigma = 1) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Observed number of stages:                                                     1 #> Observed n1 (total)                                                           28 #> Z1                                                                           1.3 #> Interim decision:                                       continue to second stage #> Calculated n2(Z1) (per group)                                           32.21129 #> Calculated c2(Z1)                                                           1.71 #>   # The results suggest recruiting 32 patients for the second stage dat <- rbind(   dat,   data.frame(     endpoint = rnorm(32, mean = 0.3),     stage = rep(2, 32))) analyze(data = dat,         statistics = get_example_statistics(),         data_distribution = Normal(FALSE),         design = get_example_design(),         sigma = 1) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Observed number of stages:                                                     2 #> Observed n1 (total)                                                           28 #> Z1                                                                           1.3 #> Interim decision:                                       continue to second stage #> Calculated n2(Z1) (per group)                                           32.21129 #> Calculated c2(Z1)                                                           1.71 #> Observed n2 (in total)                                                        32 #> Z2                                                                          2.66 #> Final test decision:                                                 reject null #>  #> Stage 2 results: #>  Sample mean:                                                          0.3656173 #>  Pseudo Rao-Blackwellized:                                             0.3135628 #>  Median unbiased (LR test ordering):                                   0.3420742 #>  Bias reduced MLE (iterations=1):                                       0.357214 #>  SWCF ordering CI:                                       [0.04664821, 0.6142449] #>  LR test ordering CI:                                    [0.08992822, 0.6106096] #>  SWCF ordering p-value:                                               0.01321363 #>  LR test ordering p-value:                                           0.003551316 #>"},{"path":"https://jan-imbi.github.io/adestr/reference/n2_extrapol.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the second-stage sample size for a design with cached spline parameters — n2_extrapol","title":"Calculate the second-stage sample size for a design with cached spline parameters — n2_extrapol","text":"Also extrapolates results values outside [c1f, c1e].","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/n2_extrapol.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the second-stage sample size for a design with cached spline parameters — n2_extrapol","text":"","code":"n2_extrapol(design, x1)"},{"path":"https://jan-imbi.github.io/adestr/reference/n2_extrapol.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the second-stage sample size for a design with cached spline parameters — n2_extrapol","text":"design object class TwoStageDesignWithCache. x1 first-stage test statistic","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResult-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResult-method","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResult-method","text":"function extract values mu score values facet plot one facet per score. input argument list, different estimators displayed facets, differentiated color.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResult-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResult-method","text":"","code":"# S4 method for class 'EstimatorScoreResult' plot(x, y, ...)"},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResult-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResult-method","text":"x output object evaluate_estimator (EstimatorScoreResult) list objects (EstimatorScoreResultList). y unused. ... additional arguments handed ggplot.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResult-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResult-method","text":"ggplot2 object visualizing score values.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResult-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResult-method","text":"","code":"score_result1 <- evaluate_estimator(   MSE(),   estimator = SampleMean(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu=seq(-.75, 1.32, 0.03),   sigma=1) # Plotting the result of evaluate_estimator plot(score_result1)   score_result2 <- evaluate_estimator(   MSE(),   estimator = AdaptivelyWeightedSampleMean(w1 = 0.8),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu=seq(-.75, 1.32, 0.03),   sigma=1) # Plotting a list of different score results plot(c(score_result1, score_result2))"},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResultList-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResultList-method","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResultList-method","text":"function extract values mu score values facet plot one facet per score. input argument list, different estimators displayed facets, differentiated color.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResultList-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResultList-method","text":"","code":"# S4 method for class 'EstimatorScoreResultList' plot(x, y, ...)"},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResultList-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResultList-method","text":"x output object evaluate_estimator (EstimatorScoreResult) list objects (EstimatorScoreResultList). y unused. ... additional arguments handed ggplot.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResultList-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResultList-method","text":"ggplot2 object visualizing score values.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResultList-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResultList-method","text":"","code":"score_result1 <- evaluate_estimator(   MSE(),   estimator = SampleMean(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu=seq(-.75, 1.32, 0.03),   sigma=1) # Plotting the result of evaluate_estimator plot(score_result1)   score_result2 <- evaluate_estimator(   MSE(),   estimator = AdaptivelyWeightedSampleMean(w1 = 0.8),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu=seq(-.75, 1.32, 0.03),   sigma=1) # Plotting a list of different score results plot(c(score_result1, score_result2))"},{"path":"https://jan-imbi.github.io/adestr/reference/plot-list-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot performance scores for point and interval estimators — plot,list-method","title":"Plot performance scores for point and interval estimators — plot,list-method","text":"function extract values mu score values facet plot one facet per score. input argument list, different estimators displayed facets, differentiated color.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-list-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot performance scores for point and interval estimators — plot,list-method","text":"","code":"# S4 method for class 'list' plot(x, y, ...)"},{"path":"https://jan-imbi.github.io/adestr/reference/plot-list-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot performance scores for point and interval estimators — plot,list-method","text":"x output object evaluate_estimator (EstimatorScoreResult) list objects (EstimatorScoreResultList). y unused. ... additional arguments handed ggplot.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-list-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot performance scores for point and interval estimators — plot,list-method","text":"ggplot2 object visualizing score values.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-list-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot performance scores for point and interval estimators — plot,list-method","text":"","code":"score_result1 <- evaluate_estimator(   MSE(),   estimator = SampleMean(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu=seq(-.75, 1.32, 0.03),   sigma=1) # Plotting the result of evaluate_estimator plot(score_result1)   score_result2 <- evaluate_estimator(   MSE(),   estimator = AdaptivelyWeightedSampleMean(w1 = 0.8),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu=seq(-.75, 1.32, 0.03),   sigma=1) # Plotting a list of different score results plot(c(score_result1, score_result2))"},{"path":"https://jan-imbi.github.io/adestr/reference/plot_p.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot p-values and implied rejection boundaries — plot_p","title":"Plot p-values and implied rejection boundaries — plot_p","text":"Creates plot p-values implied rejection boundaries grid values first second-stage test statistics.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot_p.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot p-values and implied rejection boundaries — plot_p","text":"","code":"plot_p(   estimator,   data_distribution,   design,   mu = 0,   sigma,   boundary_color = \"lightgreen\",   subdivisions = 100,   ... )"},{"path":"https://jan-imbi.github.io/adestr/reference/plot_p.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot p-values and implied rejection boundaries — plot_p","text":"estimator object class PointEstimator, IntervalEstimator PValue. data_distribution object class Normal Student. design object class TwoStageDesign. mu expected value underlying normal distribution. sigma assumed standard deviation. boundary_color color implied rejection boundary. subdivisions number subdivisions per axis grid test statistic values. ... additional arguments handed ggplot","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot_p.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot p-values and implied rejection boundaries — plot_p","text":"ggplot2 object visualizing p-values grid possible test-statistic values.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot_p.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot p-values and implied rejection boundaries — plot_p","text":"first-stage test statistic lies futility threshold (c1f) early efficacy threshold (c1e) TwoStageDesign, second-stage test statistics. p-values regions based first-stage values. first-stage test statistic values c1f c1e, first second-stage test statistic determine p-value. rejection boundary signals line ","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot_p.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot p-values and implied rejection boundaries — plot_p","text":"","code":"plot_p(estimator = StagewiseCombinationFunctionOrderingPValue(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu = 0,   sigma = 1)"},{"path":"https://jan-imbi.github.io/adestr/news/index.html","id":"adestr-100","dir":"Changelog","previous_headings":"","what":"adestr 1.0.0","title":"adestr 1.0.0","text":"Adding test cases improvements documentation developed collaboratively. Also preparing new CRAN release.","code":""},{"path":"https://jan-imbi.github.io/adestr/news/index.html","id":"adestr-052","dir":"Changelog","previous_headings":"","what":"adestr 0.5.2","title":"adestr 0.5.2","text":"Preparing new CRAN release: adoptr back CRAN, adding collaborative produced test cases vignettes","code":""},{"path":"https://jan-imbi.github.io/adestr/news/index.html","id":"adestr-051","dir":"Changelog","previous_headings":"","what":"adestr 0.5.1","title":"adestr 0.5.1","text":"Replaced raster graphics vignettes vector graphics.","code":""},{"path":"https://jan-imbi.github.io/adestr/news/index.html","id":"adestr-050","dir":"Changelog","previous_headings":"","what":"adestr 0.5.0","title":"adestr 0.5.0","text":"CRAN release: 2023-09-27 First CRAN submission.","code":""},{"path":"https://jan-imbi.github.io/adestr/news/index.html","id":"adestr-001","dir":"Changelog","previous_headings":"","what":"adestr 0.0.1","title":"adestr 0.0.1","text":"Added NEWS.md file track changes package.","code":""}]
