[{"path":"https://jan-imbi.github.io/adestr/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2021 Jan Meis Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://jan-imbi.github.io/adestr/articles/Introduction.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Introduction to adestr","text":"package implements methods evaluate performance characteristics various point interval estimators adaptive two-stage designs prespecified sample-size recalculation rules. , allows evaluation estimators real datasets, implements methods calculate p-values. Currently, works designs objects produced R-package adoptr, calculates optimal design parameters adaptive two-stage designs. can learn adoptr : kkmann.github.io/adoptr/.","code":""},{"path":"https://jan-imbi.github.io/adestr/articles/Introduction.html","id":"fitting-a-design-with-adoptr","dir":"Articles","previous_headings":"","what":"Fitting a design with adoptr","title":"Introduction to adestr","text":"order showcase capabilities package, need trial design first. refer example adoptr documentation . can read optimal adaptive designs fitted via adoptr package : kkmann.github.io/adoptr/articles/adoptr_jss.html. sake introduction, pre-computed version first example kkmann.github.io/adoptr/articles/adoptr.html provided package via get_example_design function.","code":"library(adestr) get_example_design(two_armed = TRUE) #> TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80>"},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/articles/Introduction.html","id":"evaluating-the-mean-squared-of-an-estimator","dir":"Articles","previous_headings":"Example","what":"Evaluating the mean squared of an estimator","title":"Introduction to adestr","text":"Now created optimal adaptive design, can investigate performance characteristics various estimators mean design. end, evaluate_estimator function can used. mean squared error sample mean depends true underlying value paramter \\(\\mu\\), course unknown. Therefore, may advisable use evaluate_estimator function array values \\(\\mu\\) investigate distributional properties estimator. following, MSE sample mean vs. weighted sample mean fixed weights plotted.","code":"evaluate_estimator(  score = MSE(),  estimator = SampleMean(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(two_armed = TRUE),  mu = 0.3,  sigma = 1 ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                                           Sample mean #> Assumed sigma:                                                                 1 #> Assumed mu:                                                                  0.3 #> Results: #>  Expectation:                                                          0.3056727 #>  Bias:                                                               0.005672677 #>  Variance:                                                            0.03777784 #>  MSE:                                                                 0.03781002 mse_mle <- evaluate_estimator(   score = MSE(),   estimator = SampleMean(),   data_distribution = Normal(two_armed = TRUE),   design = get_example_design(two_armed = TRUE),   mu = seq(-0.75, 1.32, .03),   sigma = 1 ) mse_weighted_sample_means <- evaluate_estimator(   score = MSE(),   estimator = WeightedSampleMean(w1 = .8),   data_distribution = Normal(two_armed = TRUE),   design = get_example_design(two_armed = TRUE),   mu = seq(-0.75, 1.32, .03),   sigma = 1 ) plot(c(mse_mle, mse_weighted_sample_means))"},{"path":"https://jan-imbi.github.io/adestr/articles/Introduction.html","id":"analyzing-datasets","dir":"Articles","previous_headings":"Example","what":"Analyzing datasets","title":"Introduction to adestr","text":"Next, let us look package can used calculate estimates data collected. first stage data trial might look like : results suggest recruiting 23 patients per group second stage. simulate 47 patients per group: Now, can use analyze function evaluate selection estimators complete dataset: estimates presented difference means two normal distributions. Keep mind difference \\(\\mu=0.3\\) used simulation. Note median unbiased estimator performs well particular example, universally true.","code":"set.seed(321) dat <- data.frame(  endpoint = c(rnorm(56, .3, 1), rnorm(56, 0, 1)),  group = factor(rep(c(\"trt\", \"ctl\"),                     c(56,56)), levels = c(\"trt\", \"ctl\")),  stage = rep(1, 112) ) head(dat) #>      endpoint group stage #> 1  2.00490322   trt     1 #> 2 -0.41203856   trt     1 #> 3  0.02201509   trt     1 #> 4  0.18035098   trt     1 #> 5  0.17603938   trt     1 #> 6  0.56818377   trt     1 analyze(data = dat,         statistics = list(),         data_distribution = Normal(two_armed = TRUE),         design = get_example_design(two_armed = TRUE),         sigma = 1) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Observed number of stages:                                                     1 #> Observed n1 (group 1)                                                         56 #> Observed n1 (group 2)                                                         56 #> Observed n1 (total)                                                          112 #> Z1                                                                          1.75 #> Interim decision:                                       continue to second stage #> Calculated n2(Z1) (per group)                                           46.99923 #> Calculated c2(Z1)                                                           1.14 dat <- rbind(dat,              data.frame(                endpoint = c(rnorm(47, .3, 1), rnorm(47, 0, 1)),                group = factor(rep(c(\"trt\", \"ctl\"),                                   c(47, 47)), levels = c(\"trt\", \"ctl\")),                stage = rep(2, 94)              )) analyze(  data = dat,  statistics = c(    SampleMean(),    BiasReduced(),    PseudoRaoBlackwell(),    MedianUnbiasedStagewiseCombinationFunctionOrdering(),    StagewiseCombinationFunctionOrderingCI(),    StagewiseCombinationFunctionOrderingPValue()    ),  data_distribution = Normal(two_armed = TRUE),  sigma = 1,  design = get_example_design(two_armed = TRUE) ) #> Design:                              TwoStageDesign<n1=56;0.8<=x1<=2.3:n2=18-80> #> Data Distribution:                                             Normal<two-armed> #> Observed number of stages:                                                     2 #> Observed n1 (group 1)                                                         56 #> Observed n1 (group 2)                                                         56 #> Observed n1 (total)                                                          112 #> Z1                                                                          1.75 #> Interim decision:                                       continue to second stage #> Calculated n2(Z1) (per group)                                           46.99923 #> Calculated c2(Z1)                                                           1.14 #> Observed n2 (group 1)                                                         47 #> Observed n2 (group 2)                                                         47 #> Observed n2 (in total)                                                        94 #> Z2                                                                          2.71 #> Final test decision:                                                 reject null #>  #> Stage 2 results: #>  Sample mean:                                                           0.434684 #>  Bias reduced MLE (iterations=1):                                      0.4221533 #>  Pseudo Rao-Blackwellized:                                             0.2658506 #>  Median unbiased (SWCF ordering):                                      0.3047428 #>  SWCF ordering CI:                                       [0.04435513, 0.5484439] #>  SWCF ordering p-value:                                               0.01097266"},{"path":"https://jan-imbi.github.io/adestr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jan Meis. Author, maintainer.","code":""},{"path":"https://jan-imbi.github.io/adestr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Meis J (2023). adestr: Adaptive Design Estimation R. R package version 0.5.0, https://jan-imbi.github.io/adestr/.","code":"@Manual{,   title = {adestr: Adaptive Design Estimation in R},   author = {Jan Meis},   year = {2023},   note = {R package version 0.5.0},   url = {https://jan-imbi.github.io/adestr/}, }"},{"path":"https://jan-imbi.github.io/adestr/index.html","id":"adestr-","dir":"","previous_headings":"","what":"Adaptive Design Estimation in R","title":"Adaptive Design Estimation in R","text":"package implements methods evaluate performance characteristics various point interval estimators adaptive two-stage designs prespecified sample-size recalculation rules. , allows evaluation estimators real datasets, implements methods calculate p-values. Currently, works designs objects produced R-package adoptr, calculates optimal design parameters adaptive two-stage designs.","code":""},{"path":"https://jan-imbi.github.io/adestr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Adaptive Design Estimation in R","text":"can install development version adestr typing R console.","code":"remotes::install_github(\"https://github.com/jan-imbi/adestr\")"},{"path":"https://jan-imbi.github.io/adestr/index.html","id":"information-for-reviewers","dir":"","previous_headings":"","what":"Information for reviewers","title":"Adaptive Design Estimation in R","text":"scripts reproduce results paper can found /data/code/ directory repository. results located /data/ directory. easiest way inspect results clone repository.","code":""},{"path":"https://jan-imbi.github.io/adestr/index.html","id":"general-example-for-usage-of-the-package","dir":"","previous_headings":"","what":"General example for usage of the package","title":"Adaptive Design Estimation in R","text":"quick example showing capabilities adestr. First, load adestr: , can evaluate performance estimator like :  can analyze dataset like :","code":"library(adestr) #> Loading required package: adoptr evaluate_estimator(  score = MSE(),  estimator = SampleMean(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(),  mu = c(0, 0.3, 0.6),  sigma = 1 ) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                             Normal<two-armed> #> Estimator:                                                           Sample mean #> Assumed sigma:                                                                 1 #> Assumed mu:                                                          0.0 0.3 0.6 #> Results: #>  Expectation:                                -0.03523827  0.28169661  0.63556746 #>  Bias:                                       -0.03523827 -0.01830339  0.03556746 #>  Variance:                                      0.05558910 0.07330464 0.06591361 #>  MSE:                                           0.05683084 0.07363966 0.06717865  evaluate_estimator(  score = MSE(),  estimator = SampleMean(),  data_distribution = Normal(two_armed = TRUE),  design = get_example_design(),  mu = seq(-0.7, 1.5, .05),  sigma = 1 ) |>    plot() set.seed(321) dat <- data.frame(  endpoint = c(rnorm(28, .2, 1), rnorm(28, 0, 1),               rnorm(23, .2, 1), rnorm(23, 0, 1)),  group = factor(rep(c(\"ctl\", \"trt\", \"ctl\", \"trt\"),                     c(28,28,23,23))),  stage = rep(c(1L, 2L), c(56, 46)) ) analyze(  data = dat,  statistics = get_example_statistics(),  data_distribution = Normal(two_armed = TRUE),  sigma = 1,  design = get_example_design() ) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                             Normal<two-armed> #> Observed number of stages:                                                     2 #> Observed n1 (group 1)                                                         28 #> Observed n1 (group 2)                                                         28 #> Observed n1 (total)                                                           56 #> Z1                                                                          1.75 #> Interim decision:                                       continue to second stage #> Calculated n2(Z1) (per group)                                                 23 #> Calculated c2(Z1)                                                           1.14 #> Observed n2 (group 1)                                                         23 #> Observed n2 (group 2)                                                         23 #> Observed n2 (in total)                                                        46 #> Z2                                                                          2.12 #> Final test decision:                                                 reject null #>  #> Stage 2 results: #>  Sample mean:                                                          0.5389012 #>  Pseudo Rao-Blackwellized:                                             0.3632916 #>  Median unbiased (LR test ordering):                                   0.5069941 #>  Bias reduced MLE (iterations=1):                                      0.5253743 #>  SWCF ordering CI:                                       [0.06264641, 0.7431231] #>  LR test ordering CI:                                       [0.2504091, 0.81829] #>  SWCF ordering p-value:                                               0.01097483 #>  LR test ordering p-value:                                          6.653031e-05"},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Performance scores for point and interval estimators — EstimatorScore-class","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"classes encode various metrics can used evaluate performance characteristics point interval estimators.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"","code":"Expectation()  Bias()  Variance()  MSE()  OverestimationProbability()  Coverage()  SoftCoverage(shrinkage = 1)  Width()  TestAgreement()  Centrality(interval = NULL)"},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"shrinkage shrinkage factor bump function. interval confidence interval respect centrality point estimator evaluated.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"EstimatorScore object.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"label name performance score. Used printing methods.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"details-on-the-implemented-estimators","dir":"Reference","previous_headings":"","what":"Details on the implemented estimators","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"following, precise definitions performance scores implemented adestr given. end, let \\(\\hat{\\mu}\\) denote point estimator, (\\(\\hat{l}\\), \\(\\hat{u}\\)) interval estimator, denote expected value random variable \\(\\mathbb{E}\\), probability event \\(P\\), let \\(\\mu\\) real value underlying parameter estimated.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"scores-for-point-estimators-pointestimatorscore-","dir":"Reference","previous_headings":"","what":"Scores for point estimators (PointEstimatorScore):","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"Expectation(): \\(\\mathbb{E}[\\hat{\\mu}]\\) Bias(): \\(\\mathbb{E}[\\hat{\\mu} - \\mu]\\) Variance(): \\(\\mathbb{E}[(\\hat{\\mu} - \\mathbb{E}[\\hat{\\mu}])^2]\\) MSE(): \\(\\mathbb{E}[(\\hat{\\mu} - mu)^2]\\) OverestimationProbability(): \\(P(\\hat{\\mu} > \\mu)\\) Centrality(interval): \\(\\mathbb{E}[(\\hat{\\mu} - \\hat{l}) + (\\hat{\\mu} - \\hat{u}]\\)","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"scores-for-confidence-intervals-intervalestimatorscore-","dir":"Reference","previous_headings":"","what":"Scores for confidence intervals (IntervalEstimatorScore):","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"Coverage(): \\(P(\\hat{l} \\leq \\mu \\leq \\hat{u})\\) Width(): \\(\\mathbb{E}[\\hat{u} - \\hat{l}]\\) TestAgreement(): \\(P\\left( \\left(\\{0 < \\hat{l} \\text{ } (c_{1, e} < Z_1 \\text{ } c_{2}(Z_1) < Z_2 ) \\right) \\text{ } \\left(\\{\\hat{l} \\leq 0  \\text{ } ( Z_1 < c_{1, f} \\text{ } Z_2 \\leq c_{2}(Z_1))\\}\\right)\\right)\\)","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/EstimatorScore-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performance scores for point and interval estimators — EstimatorScore-class","text":"","code":"evaluate_estimator(   score = MSE(),   estimator = SampleMean(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu = c(0, 0.3, 0.6),   sigma = 1,   exact = FALSE ) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Estimator:                                                           Sample mean #> Assumed sigma:                                                                 1 #> Assumed mu:                                                          0.0 0.3 0.6 #> Results: #>  Expectation:                                -0.02491922  0.30567290  0.62041636 #>  Bias:                                    -0.024919220  0.005672903  0.020416356 #>  Variance:                                      0.02779122 0.03777824 0.02790974 #>  MSE:                                           0.02841219 0.03781042 0.02832657 #>   evaluate_estimator(   score = Coverage(),   estimator = StagewiseCombinationFunctionOrderingCI(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu = c(0, 0.3),   sigma = 1,   exact = FALSE ) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Estimator:                                                      SWCF ordering CI #> Assumed sigma:                                                                 1 #> Assumed mu:                                                              0.0 0.3 #> Results: #>  Coverage:                                                   0.9500681 0.9499744 #>"},{"path":"https://jan-imbi.github.io/adestr/reference/IntervalEstimator-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Interval estimators — IntervalEstimator-class","title":"Interval estimators — IntervalEstimator-class","text":"parent class confidence intervals implemented package. Currently, confidence intervals parameter \\(\\mu\\) normal distribution implemented. Details methods calculating confidence intervals can found (upcoming paper).","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/IntervalEstimator-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interval estimators — IntervalEstimator-class","text":"","code":"IntervalEstimator(two_sided, l1, u1, l2, u2, label)  RepeatedCI(two_sided = TRUE)  StagewiseCombinationFunctionOrderingCI(two_sided = TRUE)  MLEOrderingCI(two_sided = TRUE)  LikelihoodRatioOrderingCI(two_sided = TRUE)  ScoreTestOrderingCI(two_sided = TRUE)  NeymanPearsonOrderingCI(two_sided = TRUE, mu0 = 0, mu1 = 0.4)  NaiveCI(two_sided = TRUE)"},{"path":"https://jan-imbi.github.io/adestr/reference/IntervalEstimator-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interval estimators — IntervalEstimator-class","text":"two_sided logical indicating whether confidence interval two-sided. l1 functional representation lower boundary interval early futility efficacy regions. u1 functional representation upper boundary interval early futility efficacy regions. l2 functional representation lower boundary interval continuation region. u2 functional representation upper boundary interval continuation region. label name estimator. Used printing methods. mu0 expected value normal distribution null hypothesis. mu1 expected value normal distribution null hypothesis.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/IntervalEstimator-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interval estimators — IntervalEstimator-class","text":"object class IntervalEstimator.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/IntervalEstimator-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Interval estimators — IntervalEstimator-class","text":"implemented confidence intervals : MLEOrderingCI() LikelihoodRatioOrderingCI() ScoreTestOrderingCI() StagewiseCombinationFunctionOrderingCI() confidence intervals constructed specifying ordering sample space finding value \\(\\mu\\), observed sample \\(\\alpha/2\\) ((\\(1-\\alpha/2\\))) quantile sample space according chosen ordering. implemented orderings based work presented (Emerson Fleming 1990) , (Sections 8.4 Jennison Turnbull 1999) , (Sections 4.1.1 8.2.1 Wassmer Brannath 2016) .","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/IntervalEstimator-class.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Interval estimators — IntervalEstimator-class","text":"Emerson SS, Fleming TR (1990). “Parameter estimation following group sequential hypothesis testing.” Biometrika, 77(4), 875--892. doi:10.2307/2337110 . Jennison C, Turnbull BW (1999). Group Sequential Methods Applications Clinical Trials, 1 edition. Chapman Hall/CRC., New York. doi:10.1201/9780367805326 . Wassmer G, Brannath W (2016). Group Sequential Confirmatory Adaptive Designs Clinical Trials, 1 edition. Springer, Cham, Switzerland. doi:10.1007/978-3-319-32562-0 .","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/IntervalEstimator-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interval estimators — IntervalEstimator-class","text":"","code":"# This is the definition of the 'naive' confidence interval for one-armed trials IntervalEstimator(   two_sided = TRUE,   l1 = \\(smean1, n1, sigma, ...) smean1 - qnorm(.95, sd = sigma/sqrt(n1)),   u1 = \\(smean1, n1, sigma, ...) smean1 + qnorm(.95, sd = sigma/sqrt(n1)),   l2 = \\(smean1, smean2, n1, n2, sigma, ...) smean2 - qnorm(.95, sd = sigma/sqrt(n1 + n2)),   u2 = \\(smean1, smean2, n1, n2, sigma, ...) smean2 + qnorm(.95, sd = sigma/sqrt(n1 + n2)),   label=\"My custom CI\") #> My custom CI"},{"path":"https://jan-imbi.github.io/adestr/reference/Normal.html","id":null,"dir":"Reference","previous_headings":"","what":"Normally distributed data with known variance — Normal","title":"Normally distributed data with known variance — Normal","text":"function creates object representing distributional assumptions data: normally distributed outcomes sample trial one two arms (depending value parameter two_armed), assumption known variance.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/Normal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normally distributed data with known variance — Normal","text":"","code":"Normal(two_armed = TRUE)"},{"path":"https://jan-imbi.github.io/adestr/reference/Normal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normally distributed data with known variance — Normal","text":"two_armed (logical) determines whether one two-armed trials assumed.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/NormalPrior.html","id":null,"dir":"Reference","previous_headings":"","what":"Normal prior distribution for the parameter mu — NormalPrior","title":"Normal prior distribution for the parameter mu — NormalPrior","text":"Normal prior distribution parameter mu","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/NormalPrior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normal prior distribution for the parameter mu — NormalPrior","text":"","code":"NormalPrior(mu = 0, sigma = 1)"},{"path":"https://jan-imbi.github.io/adestr/reference/NormalPrior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normal prior distribution for the parameter mu — NormalPrior","text":"mu mean prior distribution. sigma standard deviation prior distribution.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/NormalPrior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normal prior distribution for the parameter mu — NormalPrior","text":"object class NormalPrior.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/NormalPrior.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Normal prior distribution for the parameter mu — NormalPrior","text":"","code":"NormalPrior(mu = 0, sigma = 1) #> NormalPrior<mu=0;sigma=1>"},{"path":"https://jan-imbi.github.io/adestr/reference/PValue-class.html","id":null,"dir":"Reference","previous_headings":"","what":"P-values — PValue-class","title":"P-values — PValue-class","text":"parent class p-values implemented package. Details methods calculating p-values can found (upcoming paper).","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PValue-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"P-values — PValue-class","text":"","code":"PValue(g1, g2, label)  LinearShiftRepeatedPValue(wc1f = 0, wc1e = 1/2, wc2 = 1/2)  MLEOrderingPValue()  LikelihoodRatioOrderingPValue()  ScoreTestOrderingPValue()  StagewiseCombinationFunctionOrderingPValue()  NeymanPearsonOrderingPValue(mu0 = 0, mu1 = 0.4)"},{"path":"https://jan-imbi.github.io/adestr/reference/PValue-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"P-values — PValue-class","text":"g1 functional representation p-value early futility efficacy regions. g2 functional representation p-value continuation region. label name p-value. Used printing methods. wc1f slope futility boundary change. wc1e slope efficacy boundary change. wc2 slope c2 boundary change. mu0 expected value normal distribution null hypothesis. mu1 expected value normal distribution null hypothesis.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PValue-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"P-values — PValue-class","text":"object class PValue.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PValue-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"P-values — PValue-class","text":"implemented p-values : MLEOrderingPValue() LikelihoodRatioOrderingPValue() ScoreTestOrderingPValue() StagewiseCombinationFunctionOrderingPValue() p-values calculated specifying ordering sample space calculating probability random sample null hypothesis larger observed sample. implemented orderings based work presented (Emerson Fleming 1990) , (Sections 8.4 Jennison Turnbull 1999) , (Sections 4.1.1 8.2.1 Wassmer Brannath 2016) .","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PValue-class.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"P-values — PValue-class","text":"Emerson SS, Fleming TR (1990). “Parameter estimation following group sequential hypothesis testing.” Biometrika, 77(4), 875--892. doi:10.2307/2337110 . Jennison C, Turnbull BW (1999). Group Sequential Methods Applications Clinical Trials, 1 edition. Chapman Hall/CRC., New York. doi:10.1201/9780367805326 . Wassmer G, Brannath W (2016). Group Sequential Confirmatory Adaptive Designs Clinical Trials, 1 edition. Springer, Cham, Switzerland. doi:10.1007/978-3-319-32562-0 .","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/PValue-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"P-values — PValue-class","text":"","code":"# This is the definition of a 'naive' p-value based on a Z-test for a one-armed trial PValue(   g1 = \\(smean1, n1, sigma, ...) pnorm(smean1*sqrt(n1)/sigma, lower.tail=FALSE),   g2 = \\(smean1, smean2, n1, n2, ...) pnorm((n1 * smean1 + n2 * smean2)/(n1 + n2) *                                         sqrt(n1+n2)/sigma, lower.tail=FALSE),   label=\"My custom p-value\") #> My custom p-value"},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Point estimators — PointEstimator-class","title":"Point estimators — PointEstimator-class","text":"parent class point estimators implemented package. Currently, estimators parameter \\(\\mu\\) normal distribution implemented.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Point estimators — PointEstimator-class","text":"","code":"PointEstimator(g1, g2, label)  SampleMean()  FirstStageSampleMean()  WeightedSampleMean(w1 = 0.5)  AdaptivelyWeightedSampleMean(w1 = 1/sqrt(2))  MinimizePeakVariance()  BiasReduced(iterations = 1L)  RaoBlackwell()  PseudoRaoBlackwell()  MidpointStagewiseCombinationFunctionOrderingCI()  MidpointMLEOrderingCI()  MidpointLikelihoodRatioOrderingCI()  MidpointScoreTestOrderingCI()  MidpointNeymanPearsonOrderingCI()  MedianUnbiasedStagewiseCombinationFunctionOrdering()  MedianUnbiasedMLEOrdering()  MedianUnbiasedLikelihoodRatioOrdering()  MedianUnbiasedScoreTestOrdering()  MedianUnbiasedNeymanPearsonOrdering(mu0 = 0, mu1 = 0.4)"},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Point estimators — PointEstimator-class","text":"g1 functional representation estimator early futility efficacy regions. g2 functional representation estimator continuation region. label name estimator. Used printing methods. w1 weight first-stage data. iterations number bias reduction iterations. Defaults 1. mu0 expected value normal distribution null hypothesis. mu1 expected value normal distribution null hypothesis.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Point estimators — PointEstimator-class","text":"object class PointEstimator.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Point estimators — PointEstimator-class","text":"Details point estimators can found (upcoming paper).","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"sample-mean-samplemean-","dir":"Reference","previous_headings":"","what":"Sample Mean (SampleMean())","title":"Point estimators — PointEstimator-class","text":"sample mean maximum likelihood estimator mean probably 'straightforward' implemented estimators.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"fixed-weighted-sample-means-weightedsamplemean-","dir":"Reference","previous_headings":"","what":"Fixed weighted sample means (WeightedSampleMean())","title":"Point estimators — PointEstimator-class","text":"first- second-stage (available) sample means combined via fixed, predefined weights. See (Brannath et al. 2006)  (Section 8.3.2 Wassmer Brannath 2016) .","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"adaptively-weighted-sample-means-adaptivelyweightedsamplemean-","dir":"Reference","previous_headings":"","what":"Adaptively weighted sample means (AdaptivelyWeightedSampleMean())","title":"Point estimators — PointEstimator-class","text":"first- second-stage (available) sample means combined via combination fixed adaptively modified weights depend standard error. See (Section 8.3.4 Wassmer Brannath 2016) .","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"minimizing-peak-variance-in-adaptively-weighted-sample-means-minimizepeakvariance-","dir":"Reference","previous_headings":"","what":"Minimizing peak variance in adaptively weighted sample means (MinimizePeakVariance())","title":"Point estimators — PointEstimator-class","text":"estimator, weights adaptively weighted sample mean chosen minimize variance estimator value \\(\\mu\\) maximizes expected sample size.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"-pseudo-rao-blackwell-estimators-raoblackwell-and-pseudoraoblackwell-","dir":"Reference","previous_headings":"","what":"(Pseudo) Rao-Blackwell estimators (RaoBlackwell and PseudoRaoBlackwell)","title":"Point estimators — PointEstimator-class","text":"conditional expectation first-stage sample mean given overall sample mean second-stage sample size. See (Emerson Kittelson 1997) .","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"a-bias-reduced-estimator-biasreduced-","dir":"Reference","previous_headings":"","what":"A bias-reduced estimator (BiasReduced())","title":"Point estimators — PointEstimator-class","text":"estimator calculated subtracting estimate bias MLE. See (Whitehead 1986) .","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"median-unbiased-estimators","dir":"Reference","previous_headings":"","what":"Median-unbiased estimators","title":"Point estimators — PointEstimator-class","text":"implemented median-unbiased estimators : MedianUnbiasedMLEOrdering() MedianUnbiasedLikelihoodRatioOrdering() MedianUnbiasedScoreTestOrdering() MedianUnbiasedStagewiseCombinationFunctionOrdering() estimators constructed specifying ordering sample space finding value \\(\\mu\\), observed sample median sample space according chosen ordering. implemented orderings based work presented (Emerson Fleming 1990) , (Sections 8.4 Jennison Turnbull 1999) , (Sections 4.1.1 8.2.1 Wassmer Brannath 2016) .","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Point estimators — PointEstimator-class","text":"Brannath W, König F, Bauer P (2006). “Estimation flexible two stage designs.” Statistics Medicine, 25(19), 3366-3381. doi:10.1002/sim.2258 . Emerson SS, Fleming TR (1990). “Parameter estimation following group sequential hypothesis testing.” Biometrika, 77(4), 875--892. doi:10.2307/2337110 . Emerson SS, Kittelson JM (1997). “computationally simpler algorithm UMVUE normal mean following group sequential trial.” Biometrics, 53(1), 365--369. doi:10.2307/2533122 . Jennison C, Turnbull BW (1999). Group Sequential Methods Applications Clinical Trials, 1 edition. Chapman Hall/CRC., New York. doi:10.1201/9780367805326 . Wassmer G, Brannath W (2016). Group Sequential Confirmatory Adaptive Designs Clinical Trials, 1 edition. Springer, Cham, Switzerland. doi:10.1007/978-3-319-32562-0 . Whitehead J (1986). “bias maximum likelihood estimation following sequential test.” Biometrika, 73(3), 573--581. doi:10.2307/2336521 .","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/PointEstimator-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Point estimators — PointEstimator-class","text":"","code":"PointEstimator(g1 = \\(smean1, ...) smean1,g2 = \\(smean2, ...) smean2, label=\"My custom estimator\") #> My custom estimator"},{"path":"https://jan-imbi.github.io/adestr/reference/Statistic-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Statistics and Estimators of the adestr package — Statistic-class","title":"Statistics and Estimators of the adestr package — Statistic-class","text":"Statistic class parent class classes Estimator PValue. Estimator class parent classes PointEstimator ConfidenceInterval.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/Statistic-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Statistics and Estimators of the adestr package — Statistic-class","text":"label name statistic. Used printing methods.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/Statistic-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Statistics and Estimators of the adestr package — Statistic-class","text":"function analyze can used calculate value Statistic given dataset. function evaluate_estimator can used evaluate distributional quantities Estimator like MSE PointEstimator Coverage ConfidenceInterval.","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/Student.html","id":null,"dir":"Reference","previous_headings":"","what":"Normally distributed data with unknown variance — Student","title":"Normally distributed data with unknown variance — Student","text":"function creates object representing distributional assumptions data: normally distributed outcomes sample trial one two arms (depending value parameter two_armed), assumption known variance.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/Student.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normally distributed data with unknown variance — Student","text":"","code":"Student(two_armed = TRUE)"},{"path":"https://jan-imbi.github.io/adestr/reference/Student.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normally distributed data with unknown variance — Student","text":"two_armed (logical) determines whether one two-armed trials assumed.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/TwoStageDesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Two-stage designs — TwoStageDesign-class","title":"Two-stage designs — TwoStageDesign-class","text":"re-export TwoStageDesign class adoptr (Kunzmann et al. 2021)  package.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/TwoStageDesign-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Two-stage designs — TwoStageDesign-class","text":"function currently re-exported resolve CRAN conflicts. details, please refer paper (Kunzmann et al. 2021)  original github repository https://github.com/kkmann/adoptr.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/TwoStageDesign-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Two-stage designs — TwoStageDesign-class","text":"n1 (numeric) first-stage sample size. c1f (numeric) first-stage futility boundary. c1e (numeric) first-stage early efficacy boundary. n2_pivots (numeric) vector containing values n2 spline function. c2_pivots (numeric) vector containing values second-stage rejection boundary spline c2 x1_norm_pivots (numeric) vector containing x-axis (z-sclae) points n2 c2 splines weights (numeric) vector containing integration weights tunable (logical) vector determining whether desing paramters optimized","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/TwoStageDesignWithCache.html","id":null,"dir":"Reference","previous_headings":"","what":"TwoStageDesignWithCache constructor function — TwoStageDesignWithCache","title":"TwoStageDesignWithCache constructor function — TwoStageDesignWithCache","text":"Creates object class TwoStageDesignWithCache. object stores precalculated spline paramters n2 c2 functions, allows quicker evaluation.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/TwoStageDesignWithCache.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"TwoStageDesignWithCache constructor function — TwoStageDesignWithCache","text":"","code":"TwoStageDesignWithCache(design)"},{"path":"https://jan-imbi.github.io/adestr/reference/TwoStageDesignWithCache.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"TwoStageDesignWithCache constructor function — TwoStageDesignWithCache","text":"design object class TwoStageDesign","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/UniformPrior.html","id":null,"dir":"Reference","previous_headings":"","what":"Uniform prior distribution for the parameter mu — UniformPrior","title":"Uniform prior distribution for the parameter mu — UniformPrior","text":"Uniform prior distribution parameter mu","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/UniformPrior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Uniform prior distribution for the parameter mu — UniformPrior","text":"","code":"UniformPrior(min = -1, max = 1)"},{"path":"https://jan-imbi.github.io/adestr/reference/UniformPrior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Uniform prior distribution for the parameter mu — UniformPrior","text":"min minimum support interval. max maximum support interval.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/UniformPrior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Uniform prior distribution for the parameter mu — UniformPrior","text":"object class UniformPrior.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/UniformPrior.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Uniform prior distribution for the parameter mu — UniformPrior","text":"","code":"UniformPrior(min = -1, max = 1) #> UniformPrior<min=-1;max=1>"},{"path":"https://jan-imbi.github.io/adestr/reference/adestr.html","id":null,"dir":"Reference","previous_headings":"","what":"adestr — adestr","title":"adestr — adestr","text":"Point estimates, confidence intervals, p-values optimal adaptive two-stage designs.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/adestr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"adestr — adestr","text":"package implements methods evaluate performance characteristics various point interval estimators optimal adaptive two-stage designs. Specifically, package written interface trial designs created adoptr package (Kunzmann et al. 2021; Pilz et al. 2021) . Apart priori evaluation performance characteristics, package also allows calculation values estimators given real datasets, implements methods calculate p-values.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/adestr.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"adestr — adestr","text":"Kunzmann K, Pilz M, Herrmann C, Rauch G, Kieser M (2021). “adoptr package: Adaptive Optimal Designs Clinical Trials R.” Journal Statistical Software, 98(9), 1–21. doi:10.18637/jss.v098.i09 . Pilz M, Kunzmann K, Herrmann C, Rauch G, Kieser M (2021). “Optimal planning adaptive two-stage designs.” Statistics Medicine, 40(13), 3196-3213. doi:10.1002/sim.8953 .","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/adestr.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"adestr — adestr","text":"Maintainer: Jan Meis meis@imbi.uni-heidelberg.de (ORCID)","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/analyze.html","id":null,"dir":"Reference","previous_headings":"","what":"Analyze a dataset — analyze","title":"Analyze a dataset — analyze","text":"analyze function can used calculate values list point estimators, confidence intervals, p-values given dataset.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/analyze.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analyze a dataset — analyze","text":"","code":"analyze(   data,   statistics = list(),   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for data.frame analyze(   data,   statistics = list(),   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )"},{"path":"https://jan-imbi.github.io/adestr/reference/analyze.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Analyze a dataset — analyze","text":"data data.frame containing data analyzed. statistics list objects class PointEstimator, ConfidenceInterval PValue. data_distribution object class Normal Student. use_full_twoarm_sampling_distribution logical indicating whether estimator intended used full sampling distribution two-armed trial. design object class TwoStageDesign. sigma assumed standard deviation. exact logical indicating usage exact n2 function.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/analyze.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Analyze a dataset — analyze","text":"Results object containing values statistics applied data.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/analyze.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Analyze a dataset — analyze","text":"Note adestr, statistics codes functions stage-wise sample means (stage-wise sample variances data_distribution Student). first-step, data summarized produce parameters. , list statistics evaluated values parameters. output analyze function also displays information hypothesis test interim decision. statistics list empty, information displayed.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/analyze.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Analyze a dataset — analyze","text":"","code":"set.seed(123) dat <- data.frame(   endpoint = c(rnorm(28, 0.3)),   stage = rep(1, 28) ) analyze(data = dat,         statistics = list(),         data_distribution = Normal(FALSE),         design = get_example_design(),         sigma = 1) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Observed number of stages:                                                     1 #> Observed n1 (total)                                                           28 #> Z1                                                                           1.3 #> Interim decision:                                       continue to second stage #> Calculated n2(Z1) (per group)                                           32.21129 #> Calculated c2(Z1)                                                           1.71 #>   # The results suggest recruiting 32 patients for the second stage dat <- rbind(   dat,   data.frame(     endpoint = rnorm(32, mean = 0.3),     stage = rep(2, 32))) analyze(data = dat,         statistics = get_example_statistics(),         data_distribution = Normal(FALSE),         design = get_example_design(),         sigma = 1) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Observed number of stages:                                                     2 #> Observed n1 (total)                                                           28 #> Z1                                                                           1.3 #> Interim decision:                                       continue to second stage #> Calculated n2(Z1) (per group)                                           32.21129 #> Calculated c2(Z1)                                                           1.71 #> Observed n2 (in total)                                                        32 #> Z2                                                                          2.66 #> Final test decision:                                                 reject null #>  #> Stage 2 results: #>  Sample mean:                                                          0.3656173 #>  Pseudo Rao-Blackwellized:                                             0.3135628 #>  Median unbiased (LR test ordering):                                   0.3420742 #>  Bias reduced MLE (iterations=1):                                       0.357214 #>  SWCF ordering CI:                                       [0.04664821, 0.6142449] #>  LR test ordering CI:                                    [0.08992822, 0.6106096] #>  SWCF ordering p-value:                                               0.01321363 #>  LR test ordering p-value:                                           0.003551316 #>"},{"path":"https://jan-imbi.github.io/adestr/reference/c-EstimatorScoreResult-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResult-method","title":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResult-method","text":"Creates object class EstimatoreScoreResultList, basically list respective EstimatoreScoreResult objects.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/c-EstimatorScoreResult-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResult-method","text":"","code":"# S4 method for EstimatorScoreResult c(x, ...)"},{"path":"https://jan-imbi.github.io/adestr/reference/c-EstimatorScoreResult-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResult-method","text":"x object class EstimatorScoreResult. ... additional arguments passed along list function","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/c-EstimatorScoreResult-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResult-method","text":"object class EstimatoreScoreResultList.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/c-EstimatorScoreResultList-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResultList-method","title":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResultList-method","text":"Creates object class EstimatoreScoreResultList, basically list respective EstimatoreScoreResult objects.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/c-EstimatorScoreResultList-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResultList-method","text":"","code":"# S4 method for EstimatorScoreResultList c(x, ...)"},{"path":"https://jan-imbi.github.io/adestr/reference/c-EstimatorScoreResultList-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResultList-method","text":"x object class EstimatorScoreResult. ... additional arguments passed along list function","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/c-EstimatorScoreResultList-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine EstimatoreScoreResult objects into a list — c,EstimatorScoreResultList-method","text":"object class EstimatoreScoreResultList.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/c2_extrapol.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the second-stage critical value for a design with cached spline parameters — c2_extrapol","title":"Calculate the second-stage critical value for a design with cached spline parameters — c2_extrapol","text":"Also extrapolates results values outside [c1f, c1e].","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/c2_extrapol.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the second-stage critical value for a design with cached spline parameters — c2_extrapol","text":"","code":"c2_extrapol(design, x1)"},{"path":"https://jan-imbi.github.io/adestr/reference/c2_extrapol.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the second-stage critical value for a design with cached spline parameters — c2_extrapol","text":"design object class TwoStageDesignWithCache. x1 first-stage test statistic","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate performance characteristics of an estimator — evaluate_estimator-methods","title":"Evaluate performance characteristics of an estimator — evaluate_estimator-methods","text":"function evaluates EstimatorScore PointEstimator IntervalEstimator integrating sampling distribution.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate performance characteristics of an estimator — evaluate_estimator-methods","text":"","code":"# S4 method for PointEstimatorScore,IntervalEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for IntervalEstimatorScore,PointEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for list,Estimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for Expectation,PointEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for Bias,PointEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for Variance,PointEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for MSE,PointEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for OverestimationProbability,PointEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for Coverage,IntervalEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for SoftCoverage,IntervalEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for Width,IntervalEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for TestAgreement,IntervalEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )  # S4 method for Centrality,PointEstimator evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )"},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate performance characteristics of an estimator — evaluate_estimator-methods","text":"score performance measure evaluate. estimator object class PointEstimator, IntervalEstimator PValue. data_distribution object class Normal Student. use_full_twoarm_sampling_distribution logical indicating whether estimator intended used full sampling distribution two-armed trial. design object class TwoStageDesign. true_parameter true value parameter (used e.g. evaluating bias). mu expected value underlying normal distribution. sigma assumed standard deviation. tol relative tolerance. maxEval maximum number iterations. absError absolute tolerance. exact logical indicating usage exact n2 function. early_futility_part include early futility part integral. continuation_part include continuation part integral. early_efficacy_part include early efficacy part integral. conditional_integral treat integral conditional integral.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator-methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate performance characteristics of an estimator — evaluate_estimator-methods","text":"EstimatorScoreResult object containing performance characteristics estimator.","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator-methods.html","id":"general","dir":"Reference","previous_headings":"","what":"General","title":"Evaluate performance characteristics of an estimator — evaluate_estimator-methods","text":"First, functional representation integrand created combining information EstimatorScore object (score) PointEstimator IntervalEstimator object (estimator). sampling distribution design determined TwoStageDesign object (design) DataDistribution object (data_distribution), well assumed parameters \\(\\mu\\) (mu) \\(\\sigma\\) (sigma). parameters control various details integration problem.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator-methods.html","id":"other-parameters","dir":"Reference","previous_headings":"","what":"Other parameters","title":"Evaluate performance characteristics of an estimator — evaluate_estimator-methods","text":"two-armed data_distribution, use_full_twoarm_sampling_distribution TRUE, sample means groups integrated independently. use_full_twoarm_sampling_distribution FALSE, difference sample means integrated. true_parameter controls parameters supposed estimated. usually mu, set sigma one interested estimating standard deviation. parameter exact set FALSE (default), continuous version second-stage sample-size function n2 used. Otherwise, integer valued version function used, though considerably slower. parameters early_futility_part, continuation_part early_efficacy_part control parts sample-space integrated (default TRUE). can used conjunction parameter conditional_integral, enables calculation expected value performance score conditional reaching selected integration regions. Lastly, paramters tol, maxEval, absError control integration accuracy. handed hcubature function.","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate performance characteristics of an estimator — evaluate_estimator-methods","text":"","code":"evaluate_estimator(   score = MSE(),   estimator = SampleMean(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu = c(0, 0.3, 0.6),   sigma = 1,   exact = FALSE ) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Estimator:                                                           Sample mean #> Assumed sigma:                                                                 1 #> Assumed mu:                                                          0.0 0.3 0.6 #> Results: #>  Expectation:                                -0.02491922  0.30567290  0.62041636 #>  Bias:                                    -0.024919220  0.005672903  0.020416356 #>  Variance:                                      0.02779122 0.03777824 0.02790974 #>  MSE:                                           0.02841219 0.03781042 0.02832657 #>   evaluate_estimator(   score = Coverage(),   estimator = StagewiseCombinationFunctionOrderingCI(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu = c(0, 0.3),   sigma = 1,   exact = FALSE ) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Estimator:                                                      SWCF ordering CI #> Assumed sigma:                                                                 1 #> Assumed mu:                                                              0.0 0.3 #> Results: #>  Coverage:                                                   0.9500681 0.9499744 #>"},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate performance characteristics of an estimator — evaluate_estimator","title":"Evaluate performance characteristics of an estimator — evaluate_estimator","text":"function evaluates EstimatorScore PointEstimator IntervalEstimator integrating sampling distribution.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate performance characteristics of an estimator — evaluate_estimator","text":"","code":"evaluate_estimator(   score,   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   true_parameter = mu,   mu,   sigma,   tol = getOption(\"adestr_tol_outer\", default = .adestr_options[[\"adestr_tol_outer\"]]),   maxEval = getOption(\"adestr_maxEval_outer\", default =     .adestr_options[[\"adestr_maxEval_outer\"]]),   absError = getOption(\"adestr_absError_outer\", default =     .adestr_options[[\"adestr_absError_outer\"]]),   exact = FALSE,   early_futility_part = TRUE,   continuation_part = TRUE,   early_efficacy_part = TRUE,   conditional_integral = FALSE )"},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate performance characteristics of an estimator — evaluate_estimator","text":"score performance measure evaluate. estimator object class PointEstimator, IntervalEstimator PValue. data_distribution object class Normal Student. use_full_twoarm_sampling_distribution logical indicating whether estimator intended used full sampling distribution two-armed trial. design object class TwoStageDesign. true_parameter true value parameter (used e.g. evaluating bias). mu expected value underlying normal distribution. sigma assumed standard deviation. tol relative tolerance. maxEval maximum number iterations. absError absolute tolerance. exact logical indicating usage exact n2 function. early_futility_part include early futility part integral. continuation_part include continuation part integral. early_efficacy_part include early efficacy part integral. conditional_integral treat integral conditional integral.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate performance characteristics of an estimator — evaluate_estimator","text":"EstimatorScoreResult object containing performance characteristics estimator.","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator.html","id":"general","dir":"Reference","previous_headings":"","what":"General","title":"Evaluate performance characteristics of an estimator — evaluate_estimator","text":"First, functional representation integrand created combining information EstimatorScore object (score) PointEstimator IntervalEstimator object (estimator). sampling distribution design determined TwoStageDesign object (design) DataDistribution object (data_distribution), well assumed parameters \\(\\mu\\) (mu) \\(\\sigma\\) (sigma). parameters control various details integration problem.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator.html","id":"other-parameters","dir":"Reference","previous_headings":"","what":"Other parameters","title":"Evaluate performance characteristics of an estimator — evaluate_estimator","text":"two-armed data_distribution, use_full_twoarm_sampling_distribution TRUE, sample means groups integrated independently. use_full_twoarm_sampling_distribution FALSE, difference sample means integrated. true_parameter controls parameters supposed estimated. usually mu, set sigma one interested estimating standard deviation. parameter exact set FALSE (default), continuous version second-stage sample-size function n2 used. Otherwise, integer valued version function used, though considerably slower. parameters early_futility_part, continuation_part early_efficacy_part control parts sample-space integrated (default TRUE). can used conjunction parameter conditional_integral, enables calculation expected value performance score conditional reaching selected integration regions. Lastly, paramters tol, maxEval, absError control integration accuracy. handed hcubature function.","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_estimator.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate performance characteristics of an estimator — evaluate_estimator","text":"","code":"evaluate_estimator(   score = MSE(),   estimator = SampleMean(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu = c(0, 0.3, 0.6),   sigma = 1,   exact = FALSE ) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Estimator:                                                           Sample mean #> Assumed sigma:                                                                 1 #> Assumed mu:                                                          0.0 0.3 0.6 #> Results: #>  Expectation:                                -0.02491922  0.30567290  0.62041636 #>  Bias:                                    -0.024919220  0.005672903  0.020416356 #>  Variance:                                      0.02779122 0.03777824 0.02790974 #>  MSE:                                           0.02841219 0.03781042 0.02832657 #>   evaluate_estimator(   score = Coverage(),   estimator = StagewiseCombinationFunctionOrderingCI(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu = c(0, 0.3),   sigma = 1,   exact = FALSE ) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Estimator:                                                      SWCF ordering CI #> Assumed sigma:                                                                 1 #> Assumed mu:                                                              0.0 0.3 #> Results: #>  Coverage:                                                   0.9500681 0.9499744 #>"},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_scenarios_parallel.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate different scenarios in parallel — evaluate_scenarios_parallel","title":"Evaluate different scenarios in parallel — evaluate_scenarios_parallel","text":"function takes list lists scores, list lists estimators, lists lists various design parameters. possible combination elements respective sublists used create separate scenarios. scenarios evaluated independelty , allowing parallelization via future framework. scenario, one call evaluate_estimator function made.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_scenarios_parallel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate different scenarios in parallel — evaluate_scenarios_parallel","text":"","code":"evaluate_scenarios_parallel(   score_lists,   estimator_lists,   data_distribution_lists,   use_full_twoarm_sampling_distribution_lists,   design_lists,   true_parameter_lists,   mu_lists,   sigma_lists,   tol_lists,   maxEval_lists,   absError_lists,   exact_lists,   early_futility_part_lists,   continuation_part_lists,   early_efficacy_part_lists,   conditional_integral_lists )"},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_scenarios_parallel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate different scenarios in parallel — evaluate_scenarios_parallel","text":"score_lists list lists estimator scores. estimator_lists list lists estimators. data_distribution_lists list lists data distributions. use_full_twoarm_sampling_distribution_lists list lists use_full_twoarm_sampling_distribution_lists parameters. design_lists list lists designs. true_parameter_lists list lists true parameters. mu_lists list lists mu vectors. sigma_lists list lists sigma values. tol_lists list lists relative tolerances. maxEval_lists list lists maxEval boundaries. absError_lists list lists absError boundaries. exact_lists list lists `exact` parameters. early_futility_part_lists list lists `early_futility_part_lists` parameters. continuation_part_lists list lists `continuation_part_lists` parameters. early_efficacy_part_lists list lists `early_efficacy_part_lists` parameters. conditional_integral_lists list lists `conditional_integral_lists` parameters.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_scenarios_parallel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate different scenarios in parallel — evaluate_scenarios_parallel","text":"list data.frames containing results respective scenarios.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_scenarios_parallel.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluate different scenarios in parallel — evaluate_scenarios_parallel","text":"Concretely, cross product first sublist scores first sublist estimators parameters calculated. cross product second sublist scores, estimators design parameters calculated. cross products together make set scenarios. combinations say first sublist scores second sublist estimators considered.","code":""},{"path":[]},{"path":"https://jan-imbi.github.io/adestr/reference/evaluate_scenarios_parallel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate different scenarios in parallel — evaluate_scenarios_parallel","text":"","code":"res <-evaluate_scenarios_parallel(  score_lists = list(c(MSE(), OverestimationProbability())),  estimator_lists =  list(c(SampleMean(), FirstStageSampleMean())),  data_distribution_lists = list(c(Normal(FALSE), Normal(TRUE))),  design_lists =  list(c(get_example_design())),  mu_lists = list(c(-1, 0, 1)),  sigma_lists = list(1) )"},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_design.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate an exemplary adaptive design — get_example_design","title":"Generate an exemplary adaptive design — get_example_design","text":"design optimized minimize expected sample size alternative hypothesis one-armed trial. boundaries chosen control type error 0.025 normally distributed test statistic (.e. known variance). alternative hypothesis mu=0.4, overall power 80%.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate an exemplary adaptive design — get_example_design","text":"","code":"get_example_design(two_armed = FALSE, label = NULL)"},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate an exemplary adaptive design — get_example_design","text":"two_armed (logical) determins whether design one- two-armed trials. label (optional) label assigned design.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_design.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate an exemplary adaptive design — get_example_design","text":"exmplary design class TwoStageDesign.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_design.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate an exemplary adaptive design — get_example_design","text":"","code":"get_example_design() #> TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40>"},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_statistics.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a list of estimators and p-values to use in examples — get_example_statistics","title":"Generate a list of estimators and p-values to use in examples — get_example_statistics","text":"Generate list estimators p-values use examples","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_statistics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a list of estimators and p-values to use in examples — get_example_statistics","text":"","code":"get_example_statistics(   point_estimators = TRUE,   interval_estimators = TRUE,   p_values = TRUE )"},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_statistics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a list of estimators and p-values to use in examples — get_example_statistics","text":"point_estimators logical indicating whether point estimators included output list interval_estimators logical indicating whether interval estimators included output list p_values logical indicating whether p-values included output list","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_statistics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a list of estimators and p-values to use in examples — get_example_statistics","text":"list estimators pvalues.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_example_statistics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a list of estimators and p-values to use in examples — get_example_statistics","text":"","code":"set.seed(123) dat <- data.frame(   endpoint = c(rnorm(28, 0.3)),   stage = rep(1, 28) ) analyze(data = dat,         statistics = list(),         data_distribution = Normal(FALSE),         design = get_example_design(),         sigma = 1) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Observed number of stages:                                                     1 #> Observed n1 (total)                                                           28 #> Z1                                                                           1.3 #> Interim decision:                                       continue to second stage #> Calculated n2(Z1) (per group)                                           32.21129 #> Calculated c2(Z1)                                                           1.71 #>   # The results suggest recruiting 32 patients for the second stage dat <- rbind(   dat,   data.frame(     endpoint = rnorm(32, mean = 0.3),     stage = rep(2, 32))) analyze(data = dat,         statistics = get_example_statistics(),         data_distribution = Normal(FALSE),         design = get_example_design(),         sigma = 1) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Observed number of stages:                                                     2 #> Observed n1 (total)                                                           28 #> Z1                                                                           1.3 #> Interim decision:                                       continue to second stage #> Calculated n2(Z1) (per group)                                           32.21129 #> Calculated c2(Z1)                                                           1.71 #> Observed n2 (in total)                                                        32 #> Z2                                                                          2.66 #> Final test decision:                                                 reject null #>  #> Stage 2 results: #>  Sample mean:                                                          0.3656173 #>  Pseudo Rao-Blackwellized:                                             0.3135628 #>  Median unbiased (LR test ordering):                                   0.3420742 #>  Bias reduced MLE (iterations=1):                                       0.357214 #>  SWCF ordering CI:                                       [0.04664821, 0.6142449] #>  LR test ordering CI:                                    [0.08992822, 0.6106096] #>  SWCF ordering p-value:                                               0.01321363 #>  LR test ordering p-value:                                           0.003551316 #>"},{"path":"https://jan-imbi.github.io/adestr/reference/get_stagewise_estimators.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional representations of an estimator or p-value — get_stagewise_estimators","title":"Conditional representations of an estimator or p-value — get_stagewise_estimators","text":"generic determines functional representations point interval estimators p-values. functions returned two parts, one part calculate values conditional early futility efficacy stops (.e. second stage mean sample size available), one conditional continuation second stage.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_stagewise_estimators.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditional representations of an estimator or p-value — get_stagewise_estimators","text":"","code":"get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for VirtualPointEstimator,ANY get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for VirtualPValue,ANY get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for VirtualIntervalEstimator,ANY get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for PointEstimator,Student get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for PValue,Student get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for IntervalEstimator,Student get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for VirtualPointEstimator,Student get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for VirtualIntervalEstimator,Student get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for VirtualPValue,Student get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for PointEstimator,DataDistribution get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for PValue,DataDistribution get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for IntervalEstimator,DataDistribution get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for AdaptivelyWeightedSampleMean,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MinimizePeakVariance,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for BiasReduced,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for RaoBlackwell,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for PseudoRaoBlackwell,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for RepeatedCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for LinearShiftRepeatedPValue,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MLEOrderingPValue,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for LikelihoodRatioOrderingPValue,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for ScoreTestOrderingPValue,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for StagewiseCombinationFunctionOrderingPValue,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for NeymanPearsonOrderingPValue,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for StagewiseCombinationFunctionOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MLEOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for LikelihoodRatioOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for ScoreTestOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for NeymanPearsonOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for NaiveCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MidpointStagewiseCombinationFunctionOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MidpointMLEOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MidpointLikelihoodRatioOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MidpointScoreTestOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MidpointNeymanPearsonOrderingCI,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MedianUnbiasedStagewiseCombinationFunctionOrdering,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MedianUnbiasedMLEOrdering,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MedianUnbiasedLikelihoodRatioOrdering,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MedianUnbiasedScoreTestOrdering,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )  # S4 method for MedianUnbiasedNeymanPearsonOrdering,Normal get_stagewise_estimators(   estimator,   data_distribution,   use_full_twoarm_sampling_distribution = FALSE,   design,   sigma,   exact = FALSE )"},{"path":"https://jan-imbi.github.io/adestr/reference/get_stagewise_estimators.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conditional representations of an estimator or p-value — get_stagewise_estimators","text":"estimator object class PointEstimator, IntervalEstimator PValue. data_distribution object class Normal Student. use_full_twoarm_sampling_distribution logical indicating whether estimator intended used full sampling distribution two-armed trial. design object class TwoStageDesign. sigma assumed standard deviation. exact logical indicating usage exact n2 function.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_stagewise_estimators.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conditional representations of an estimator or p-value — get_stagewise_estimators","text":"list conditional functional representations (one stage trial might end) estimator p-value.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_stagewise_estimators.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditional representations of an estimator or p-value — get_stagewise_estimators","text":"","code":"get_stagewise_estimators(   estimator = SampleMean(),   data_distribution = Normal(FALSE),   use_full_twoarm_sampling_distribution = FALSE,   design = get_example_design(),   sigma = 1,   exact = FALSE ) #> $g1 #> function (smean1, ...)  #> smean1 #> <bytecode: 0x555e60f710e8> #> <environment: 0x555e5f1b2328> #>  #> $g2 #> function (smean1, smean2, n1, n2, ...)  #> (n1 * smean1 + n2 * smean2)/(n1 + n2) #> <bytecode: 0x555e60f70da0> #> <environment: 0x555e5f1b2328> #>"},{"path":"https://jan-imbi.github.io/adestr/reference/get_statistics_from_paper.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a list of estimators and p-values to use in examples — get_statistics_from_paper","title":"Generate a list of estimators and p-values to use in examples — get_statistics_from_paper","text":"Generate list estimators p-values use examples","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_statistics_from_paper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a list of estimators and p-values to use in examples — get_statistics_from_paper","text":"","code":"get_statistics_from_paper(   point_estimators = TRUE,   interval_estimators = TRUE,   p_values = TRUE )"},{"path":"https://jan-imbi.github.io/adestr/reference/get_statistics_from_paper.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a list of estimators and p-values to use in examples — get_statistics_from_paper","text":"point_estimators logical indicating whether point estimators included output list interval_estimators logical indicating whether interval estimators included output list p_values logical indicating whether p-values included output list","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_statistics_from_paper.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a list of estimators and p-values to use in examples — get_statistics_from_paper","text":"list estimators pvalues.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/get_statistics_from_paper.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a list of estimators and p-values to use in examples — get_statistics_from_paper","text":"","code":"set.seed(123) dat <- data.frame(   endpoint = c(rnorm(28, 0.3)),   stage = rep(1, 28) ) analyze(data = dat,         statistics = list(),         data_distribution = Normal(FALSE),         design = get_example_design(),         sigma = 1) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Observed number of stages:                                                     1 #> Observed n1 (total)                                                           28 #> Z1                                                                           1.3 #> Interim decision:                                       continue to second stage #> Calculated n2(Z1) (per group)                                           32.21129 #> Calculated c2(Z1)                                                           1.71 #>   # The results suggest recruiting 32 patients for the second stage dat <- rbind(   dat,   data.frame(     endpoint = rnorm(32, mean = 0.3),     stage = rep(2, 32))) analyze(data = dat,         statistics = get_example_statistics(),         data_distribution = Normal(FALSE),         design = get_example_design(),         sigma = 1) #> Design:                               TwoStageDesign<n1=28;0.8<=x1<=2.3:n2=9-40> #> Data Distribution:                                          Normal<single-armed> #> Observed number of stages:                                                     2 #> Observed n1 (total)                                                           28 #> Z1                                                                           1.3 #> Interim decision:                                       continue to second stage #> Calculated n2(Z1) (per group)                                           32.21129 #> Calculated c2(Z1)                                                           1.71 #> Observed n2 (in total)                                                        32 #> Z2                                                                          2.66 #> Final test decision:                                                 reject null #>  #> Stage 2 results: #>  Sample mean:                                                          0.3656173 #>  Pseudo Rao-Blackwellized:                                             0.3135628 #>  Median unbiased (LR test ordering):                                   0.3420742 #>  Bias reduced MLE (iterations=1):                                       0.357214 #>  SWCF ordering CI:                                       [0.04664821, 0.6142449] #>  LR test ordering CI:                                    [0.08992822, 0.6106096] #>  SWCF ordering p-value:                                               0.01321363 #>  LR test ordering p-value:                                           0.003551316 #>"},{"path":"https://jan-imbi.github.io/adestr/reference/n2_extrapol.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the second-stage sample size for a design with cached spline parameters — n2_extrapol","title":"Calculate the second-stage sample size for a design with cached spline parameters — n2_extrapol","text":"Also extrapolates results values outside [c1f, c1e].","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/n2_extrapol.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the second-stage sample size for a design with cached spline parameters — n2_extrapol","text":"","code":"n2_extrapol(design, x1)"},{"path":"https://jan-imbi.github.io/adestr/reference/n2_extrapol.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the second-stage sample size for a design with cached spline parameters — n2_extrapol","text":"design object class TwoStageDesignWithCache. x1 first-stage test statistic","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResult-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResult-method","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResult-method","text":"function extract values mu score values facet plot one facet per score. input argument list, different estimators displayed facets, differentiated color.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResult-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResult-method","text":"","code":"# S4 method for EstimatorScoreResult plot(x, y, ...)"},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResult-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResult-method","text":"x output object evaluate_estimator (EstimatorScoreResult) list objects (EstimatorScoreResultList). y unused. ... additional arguments handed ggplot.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResult-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResult-method","text":"ggplot2 object visualizing score values.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResult-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResult-method","text":"","code":"score_result1 <- evaluate_estimator(   MSE(),   estimator = SampleMean(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu=seq(-.75, 1.32, 0.03),   sigma=1) # Plotting the result of evaluate_estimator plot(score_result1)   score_result2 <- evaluate_estimator(   MSE(),   estimator = AdaptivelyWeightedSampleMean(w1 = 0.8),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu=seq(-.75, 1.32, 0.03),   sigma=1) # Plotting a list of different score results plot(c(score_result1, score_result2))"},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResultList-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResultList-method","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResultList-method","text":"function extract values mu score values facet plot one facet per score. input argument list, different estimators displayed facets, differentiated color.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResultList-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResultList-method","text":"","code":"# S4 method for EstimatorScoreResultList plot(x, y, ...)"},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResultList-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResultList-method","text":"x output object evaluate_estimator (EstimatorScoreResult) list objects (EstimatorScoreResultList). y unused. ... additional arguments handed ggplot.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResultList-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResultList-method","text":"ggplot2 object visualizing score values.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-EstimatorScoreResultList-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot performance scores for point and interval estimators — plot,EstimatorScoreResultList-method","text":"","code":"score_result1 <- evaluate_estimator(   MSE(),   estimator = SampleMean(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu=seq(-.75, 1.32, 0.03),   sigma=1) # Plotting the result of evaluate_estimator plot(score_result1)   score_result2 <- evaluate_estimator(   MSE(),   estimator = AdaptivelyWeightedSampleMean(w1 = 0.8),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu=seq(-.75, 1.32, 0.03),   sigma=1) # Plotting a list of different score results plot(c(score_result1, score_result2))"},{"path":"https://jan-imbi.github.io/adestr/reference/plot-list-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot performance scores for point and interval estimators — plot,list-method","title":"Plot performance scores for point and interval estimators — plot,list-method","text":"function extract values mu score values facet plot one facet per score. input argument list, different estimators displayed facets, differentiated color.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-list-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot performance scores for point and interval estimators — plot,list-method","text":"","code":"# S4 method for list plot(x, y, ...)"},{"path":"https://jan-imbi.github.io/adestr/reference/plot-list-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot performance scores for point and interval estimators — plot,list-method","text":"x output object evaluate_estimator (EstimatorScoreResult) list objects (EstimatorScoreResultList). y unused. ... additional arguments handed ggplot.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-list-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot performance scores for point and interval estimators — plot,list-method","text":"ggplot2 object visualizing score values.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot-list-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot performance scores for point and interval estimators — plot,list-method","text":"","code":"score_result1 <- evaluate_estimator(   MSE(),   estimator = SampleMean(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu=seq(-.75, 1.32, 0.03),   sigma=1) # Plotting the result of evaluate_estimator plot(score_result1)   score_result2 <- evaluate_estimator(   MSE(),   estimator = AdaptivelyWeightedSampleMean(w1 = 0.8),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu=seq(-.75, 1.32, 0.03),   sigma=1) # Plotting a list of different score results plot(c(score_result1, score_result2))"},{"path":"https://jan-imbi.github.io/adestr/reference/plot_p.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot p-values and implied rejection boundaries — plot_p","title":"Plot p-values and implied rejection boundaries — plot_p","text":"Creates plot p-values implied rejection boundaries grid values first second-stage test statistics.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot_p.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot p-values and implied rejection boundaries — plot_p","text":"","code":"plot_p(   estimator,   data_distribution,   design,   mu = 0,   sigma,   boundary_color = \"lightgreen\",   subdivisions = 100,   ... )"},{"path":"https://jan-imbi.github.io/adestr/reference/plot_p.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot p-values and implied rejection boundaries — plot_p","text":"estimator object class PointEstimator, IntervalEstimator PValue. data_distribution object class Normal Student. design object class TwoStageDesign. mu expected value underlying normal distribution. sigma assumed standard deviation. boundary_color color implied rejection boundary. subdivisions number subdivisions per axis grid test statistic values. ... additional arguments handed ggplot","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot_p.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot p-values and implied rejection boundaries — plot_p","text":"ggplot2 object visualizing p-values grid possible test-statistic values.","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot_p.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot p-values and implied rejection boundaries — plot_p","text":"first-stage test statistic lies futility threshold (c1f) early efficacy threshold (c1e) TwoStageDesign, second-stage test statistics. p-values regions based first-stage values. first-stage test statistic values c1f c1e, first second-stage test statistic determine p-value. rejection boundary signals line ","code":""},{"path":"https://jan-imbi.github.io/adestr/reference/plot_p.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot p-values and implied rejection boundaries — plot_p","text":"","code":"plot_p(estimator = StagewiseCombinationFunctionOrderingPValue(),   data_distribution = Normal(FALSE),   design = get_example_design(),   mu = 0,   sigma = 1)"},{"path":"https://jan-imbi.github.io/adestr/news/index.html","id":"adestr-050","dir":"Changelog","previous_headings":"","what":"adestr 0.5.0","title":"adestr 0.5.0","text":"First CRAN submission.","code":""},{"path":"https://jan-imbi.github.io/adestr/news/index.html","id":"adestr-001","dir":"Changelog","previous_headings":"","what":"adestr 0.0.1","title":"adestr 0.0.1","text":"Added NEWS.md file track changes package.","code":""}]
